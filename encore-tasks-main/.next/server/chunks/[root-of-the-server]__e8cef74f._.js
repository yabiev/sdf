module.exports = {

"[project]/.next-internal/server/app/api/auth/login/route/actions.js [app-rsc] (server actions loader, ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/pg [external] (pg, esm_import)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname, a: __turbopack_async_module__ } = __turbopack_context__;
__turbopack_async_module__(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {
const mod = await __turbopack_context__.y("pg");

__turbopack_context__.n(mod);
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, true);}),
"[project]/src/lib/postgresql-adapter.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname, a: __turbopack_async_module__ } = __turbopack_context__;
__turbopack_async_module__(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {
__turbopack_context__.s({
    "PostgreSQLAdapter": (()=>PostgreSQLAdapter),
    "default": (()=>__TURBOPACK__default__export__),
    "getPostgreSQLAdapter": (()=>getPostgreSQLAdapter)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$29$__ = __turbopack_context__.i("[externals]/pg [external] (pg, esm_import)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bcryptjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bcryptjs/index.js [app-route] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$29$__
]);
([__TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__);
;
;
class PostgreSQLAdapter {
    static instance = null;
    pool;
    isInitialized = false;
    constructor(config){
        this.pool = new __TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$29$__["Pool"]({
            host: config.host,
            port: config.port,
            database: config.database,
            user: config.user,
            password: config.password,
            ssl: config.ssl ? {
                rejectUnauthorized: false
            } : false,
            max: 20,
            idleTimeoutMillis: 30000,
            connectionTimeoutMillis: 2000
        });
    }
    // Инициализация базы данных
    async initialize() {
        if (this.isInitialized) return;
        try {
            const client = await this.pool.connect();
            // Проверяем подключение
            await client.query('SELECT NOW()');
            console.log('✅ PostgreSQL подключение установлено');
            client.release();
            this.isInitialized = true;
        } catch (error) {
            console.error('❌ Ошибка подключения к PostgreSQL:', error);
            throw error;
        }
    }
    // Закрытие пула соединений
    async close() {
        await this.pool.end();
        this.isInitialized = false;
    }
    // Получение клиента для транзакций
    async getClient() {
        return await this.pool.connect();
    }
    // Выполнение запроса
    async query(text, params) {
        const client = await this.pool.connect();
        try {
            console.log('SQL Query:', text);
            console.log('SQL Params:', params);
            const result = await client.query(text, params);
            return result;
        } finally{
            client.release();
        }
    }
    // === МЕТОДЫ ДЛЯ ПОЛЬЗОВАТЕЛЕЙ ===
    async createUser(email, password, name, role = 'user') {
        const hashedPassword = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bcryptjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].hash(password, 12);
        const result = await this.query(`INSERT INTO users (email, password_hash, name, role, approval_status) 
       VALUES ($1, $2, $3, $4, $5) 
       RETURNING *`, [
            email,
            hashedPassword,
            name,
            role,
            'pending'
        ]);
        return result.rows[0];
    }
    async getUserByEmail(email) {
        const result = await this.query('SELECT * FROM users WHERE email = $1', [
            email
        ]);
        const row = result.rows[0];
        if (!row) return null;
        // Маппинг полей базы данных в User интерфейс
        return {
            id: row.id,
            userId: row.id,
            name: row.name,
            email: row.email,
            role: row.role,
            status: row.is_active ? 'active' : 'inactive',
            approval_status: row.approval_status,
            avatar: row.avatar,
            createdAt: row.created_at,
            updatedAt: row.updated_at,
            lastLoginAt: row.last_login_at,
            is_active: row.is_active,
            created_at: row.created_at,
            updated_at: row.updated_at,
            last_login_at: row.last_login_at,
            password_hash: row.password_hash // Добавляем password_hash для аутентификации
        };
    }
    async getUserById(id) {
        const result = await this.query('SELECT * FROM users WHERE id = $1', [
            id
        ]);
        const row = result.rows[0];
        if (!row) return null;
        // Маппинг полей базы данных в User интерфейс
        return {
            id: row.id,
            userId: row.id,
            name: row.name,
            email: row.email,
            role: row.role,
            status: row.is_active ? 'active' : 'inactive',
            approval_status: row.approval_status,
            avatar: row.avatar,
            createdAt: row.created_at,
            updatedAt: row.updated_at,
            lastLoginAt: row.last_login_at,
            is_active: row.is_active,
            created_at: row.created_at,
            updated_at: row.updated_at,
            last_login_at: row.last_login_at
        };
    }
    async updateUser(id, updates) {
        const fields = Object.keys(updates).filter((key)=>key !== 'id');
        const values = fields.map((field)=>updates[field]);
        const setClause = fields.map((field, index)=>`${field} = $${index + 2}`).join(', ');
        if (fields.length === 0) {
            return await this.getUserById(id);
        }
        const result = await this.query(`UPDATE users SET ${setClause} WHERE id = $1 RETURNING *`, [
            id,
            ...values
        ]);
        return result.rows[0] || null;
    }
    async getAllUsers() {
        const result = await this.query('SELECT * FROM users ORDER BY created_at DESC');
        return result.rows;
    }
    async deleteUser(id) {
        const result = await this.query('DELETE FROM users WHERE id = $1', [
            id
        ]);
        return result.rowCount > 0;
    }
    // === МЕТОДЫ ДЛЯ ПРОЕКТОВ ===
    async createProject(name, description, ownerId, color) {
        const result = await this.query(`INSERT INTO projects (name, description, creator_id, color)
     VALUES ($1, $2, $3, $4) RETURNING *`, [
            name,
            description,
            ownerId,
            color || '#3B82F6'
        ]);
        return result.rows[0];
    }
    async getProjectById(id) {
        const result = await this.query('SELECT * FROM projects WHERE id = $1 AND deleted_at IS NULL', [
            id
        ]);
        return result.rows[0] || null;
    }
    async getProjectsByUserId(userId) {
        const result = await this.query(`SELECT DISTINCT p.* FROM projects p 
       LEFT JOIN project_members pm ON p.id = pm.project_id 
       WHERE (p.creator_id = $1 OR pm.user_id = $1) AND p.deleted_at IS NULL 
       ORDER BY p.created_at DESC`, [
            userId
        ]);
        return result.rows;
    }
    async getAllProjects() {
        const result = await this.query('SELECT * FROM projects WHERE deleted_at IS NULL ORDER BY created_at DESC');
        return result.rows;
    }
    async updateProject(id, updates) {
        const fields = Object.keys(updates).filter((key)=>key !== 'id');
        const values = fields.map((field)=>updates[field]);
        const setClause = fields.map((field, index)=>`${field} = $${index + 2}`).join(', ');
        if (fields.length === 0) {
            return await this.getProjectById(id);
        }
        const result = await this.query(`UPDATE projects SET ${setClause} WHERE id = $1 RETURNING *`, [
            id,
            ...values
        ]);
        return result.rows[0] || null;
    }
    async deleteProject(id) {
        const result = await this.query('UPDATE projects SET deleted_at = CURRENT_TIMESTAMP WHERE id = $1', [
            id
        ]);
        return result.rowCount > 0;
    }
    async hasProjectAccess(userId, projectId) {
        try {
            // Проверяем, является ли пользователь владельцем проекта
            const ownerResult = await this.query('SELECT creator_id FROM projects WHERE id = $1 AND deleted_at IS NULL', [
                projectId
            ]);
            if (ownerResult.rows.length === 0) {
                return false; // Проект не найден
            }
            const projectOwner = ownerResult.rows[0].creator_id;
            if (projectOwner === userId) {
                return true; // Пользователь является владельцем
            }
            // Проверяем членство в проекте
            const memberResult = await this.query('SELECT 1 FROM project_members WHERE project_id = $1 AND user_id = $2', [
                projectId,
                userId
            ]);
            return memberResult.rows.length > 0;
        } catch (error) {
            console.error('Error checking project access:', error);
            return false;
        }
    }
    // === МЕТОДЫ ДЛЯ ДОСОК ===
    async createBoard(name, description, projectId) {
        const result = await this.query(`INSERT INTO boards (name, project_id) 
       VALUES ($1, $2) 
       RETURNING *`, [
            name,
            projectId
        ]);
        return result.rows[0];
    }
    async getBoardById(id) {
        const result = await this.query('SELECT * FROM boards WHERE id = $1 AND deleted_at IS NULL', [
            id
        ]);
        return result.rows[0] || null;
    }
    async getBoardsByProjectId(projectId) {
        const result = await this.query('SELECT * FROM boards WHERE project_id = $1 AND deleted_at IS NULL ORDER BY position ASC, created_at DESC', [
            projectId
        ]);
        return result.rows;
    }
    async updateBoard(id, updates) {
        const fields = Object.keys(updates).filter((key)=>key !== 'id');
        const values = fields.map((field)=>updates[field]);
        const setClause = fields.map((field, index)=>`${field} = $${index + 2}`).join(', ');
        if (fields.length === 0) {
            return await this.getBoardById(id);
        }
        const result = await this.query(`UPDATE boards SET ${setClause} WHERE id = $1 RETURNING *`, [
            id,
            ...values
        ]);
        return result.rows[0] || null;
    }
    async deleteBoard(id) {
        const result = await this.query('UPDATE boards SET deleted_at = CURRENT_TIMESTAMP WHERE id = $1', [
            id
        ]);
        return result.rowCount > 0;
    }
    // === МЕТОДЫ ДЛЯ КОЛОНОК ===
    async createColumn(name, boardId, position, color) {
        const result = await this.query(`INSERT INTO columns (title, board_id, position, color) 
       VALUES ($1, $2, $3, $4) 
       RETURNING *`, [
            name,
            boardId,
            position || 0,
            color || '#6B7280'
        ]);
        return result.rows[0];
    }
    async getColumnById(id) {
        const result = await this.query('SELECT * FROM columns WHERE id = $1 AND deleted_at IS NULL', [
            id
        ]);
        return result.rows[0] || null;
    }
    async getColumnsByBoardId(boardId) {
        const result = await this.query('SELECT * FROM columns WHERE board_id = $1 AND deleted_at IS NULL ORDER BY position ASC, created_at DESC', [
            boardId
        ]);
        return result.rows;
    }
    async updateColumn(id, updates) {
        const fields = Object.keys(updates).filter((key)=>key !== 'id');
        const values = fields.map((field)=>updates[field]);
        const setClause = fields.map((field, index)=>`${field} = $${index + 2}`).join(', ');
        if (fields.length === 0) {
            return await this.getColumnById(id);
        }
        const result = await this.query(`UPDATE columns SET ${setClause} WHERE id = $1 RETURNING *`, [
            id,
            ...values
        ]);
        return result.rows[0] || null;
    }
    async deleteColumn(id) {
        const result = await this.query('UPDATE columns SET deleted_at = CURRENT_TIMESTAMP WHERE id = $1', [
            id
        ]);
        return result.rowCount > 0;
    }
    // === МЕТОДЫ ДЛЯ ЗАДАЧ ===
    async createTask(taskData) {
        const { title, description, status = 'todo', priority = 'medium', project_id, board_id, column_id, assignee_id, reporter_id, position = 0 } = taskData;
        const result = await this.query(`INSERT INTO tasks (title, description, status, priority, project_id, board_id, column_id, assignee_id, reporter_id, position) 
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) 
       RETURNING *`, [
            title,
            description,
            status,
            priority,
            project_id,
            board_id,
            column_id,
            assignee_id,
            reporter_id,
            position
        ]);
        return result.rows[0];
    }
    async getTaskById(id) {
        const result = await this.query('SELECT * FROM tasks WHERE id = $1 AND deleted_at IS NULL', [
            id
        ]);
        return result.rows[0] || null;
    }
    async getTasksByProjectId(projectId) {
        const result = await this.query('SELECT * FROM tasks WHERE project_id = $1 AND deleted_at IS NULL ORDER BY position ASC, created_at DESC', [
            projectId
        ]);
        return result.rows;
    }
    async getTasksByColumnId(columnId) {
        const result = await this.query('SELECT * FROM tasks WHERE column_id = $1 AND deleted_at IS NULL ORDER BY position ASC, created_at DESC', [
            columnId
        ]);
        return result.rows;
    }
    async updateTask(id, updates) {
        const fields = Object.keys(updates).filter((key)=>key !== 'id');
        const values = fields.map((field)=>updates[field]);
        const setClause = fields.map((field, index)=>`${field} = $${index + 2}`).join(', ');
        if (fields.length === 0) {
            return await this.getTaskById(id);
        }
        const result = await this.query(`UPDATE tasks SET ${setClause} WHERE id = $1 RETURNING *`, [
            id,
            ...values
        ]);
        return result.rows[0] || null;
    }
    async deleteTask(id) {
        const result = await this.query('UPDATE tasks SET deleted_at = CURRENT_TIMESTAMP WHERE id = $1', [
            id
        ]);
        return result.rowCount > 0;
    }
    // === МЕТОДЫ ДЛЯ СЕССИЙ ===
    async createSession(sessionToken, userId, expiresAt) {
        const result = await this.query(`INSERT INTO user_sessions (session_token, user_id, expires_at)
     VALUES ($1, $2, $3)
     RETURNING *`, [
            sessionToken,
            userId,
            expiresAt
        ]);
        const row = result.rows[0];
        return {
            id: row.id,
            userId: row.user_id,
            token: row.session_token,
            expiresAt: new Date(row.expires_at),
            isActive: true,
            userAgent: row.user_agent,
            ipAddress: row.ip_address,
            lastActivityAt: new Date(row.last_activity_at || row.created_at),
            createdAt: new Date(row.created_at),
            updatedAt: new Date(row.updated_at || row.created_at)
        };
    }
    async getSessionByToken(sessionToken) {
        const result = await this.query('SELECT * FROM user_sessions WHERE session_token = $1 AND expires_at > NOW()', [
            sessionToken
        ]);
        if (!result.rows[0]) return null;
        const row = result.rows[0];
        return {
            id: row.id,
            userId: row.user_id,
            token: row.session_token,
            expiresAt: new Date(row.expires_at),
            isActive: true,
            userAgent: row.user_agent,
            ipAddress: row.ip_address,
            lastActivityAt: new Date(row.last_activity_at || row.created_at),
            createdAt: new Date(row.created_at),
            updatedAt: new Date(row.updated_at || row.created_at)
        };
    }
    async deleteSession(sessionToken) {
        const result = await this.query('DELETE FROM user_sessions WHERE session_token = $1', [
            sessionToken
        ]);
        return result.rowCount > 0;
    }
    async deleteExpiredSessions() {
        const result = await this.query('DELETE FROM user_sessions WHERE expires_at <= NOW()');
        return result.rowCount;
    }
    // === МЕТОДЫ ДЛЯ КОММЕНТАРИЕВ ===
    async createComment(content, taskId, authorId) {
        const result = await this.query(`INSERT INTO comments (content, task_id, author_id) 
       VALUES ($1, $2, $3) 
       RETURNING *`, [
            content,
            taskId,
            authorId
        ]);
        return result.rows[0];
    }
    async getCommentsByTaskId(taskId) {
        const result = await this.query('SELECT * FROM comments WHERE task_id = $1 AND deleted_at IS NULL ORDER BY created_at', [
            taskId
        ]);
        return result.rows;
    }
    async updateComment(id, content) {
        const result = await this.query('UPDATE comments SET content = $2 WHERE id = $1 RETURNING *', [
            id,
            content
        ]);
        return result.rows[0] || null;
    }
    async deleteComment(id) {
        const result = await this.query('UPDATE comments SET deleted_at = CURRENT_TIMESTAMP WHERE id = $1', [
            id
        ]);
        return result.rowCount > 0;
    }
    // === МЕТОДЫ ДЛЯ ТЕГОВ ===
    async createTag(name, color, projectId) {
        const result = await this.query(`INSERT INTO tags (name, color, project_id) 
       VALUES ($1, $2, $3) 
       RETURNING *`, [
            name,
            color,
            projectId
        ]);
        return result.rows[0];
    }
    async getTagsByProjectId(projectId) {
        const result = await this.query('SELECT * FROM tags WHERE project_id = $1 ORDER BY name', [
            projectId
        ]);
        return result.rows;
    }
    async addTagToTask(taskId, tagId) {
        try {
            await this.query('INSERT INTO task_tags (task_id, tag_id) VALUES ($1, $2)', [
                taskId,
                tagId
            ]);
            return true;
        } catch (error) {
            return false;
        }
    }
    async removeTagFromTask(taskId, tagId) {
        const result = await this.query('DELETE FROM task_tags WHERE task_id = $1 AND tag_id = $2', [
            taskId,
            tagId
        ]);
        return result.rowCount > 0;
    }
    async getTagsByTaskId(taskId) {
        const result = await this.query(`SELECT t.* FROM tags t 
       JOIN task_tags tt ON t.id = tt.tag_id 
       WHERE tt.task_id = $1`, [
            taskId
        ]);
        return result.rows;
    }
    // Статический метод для получения экземпляра (Singleton)
    static getInstance() {
        if (!PostgreSQLAdapter.instance) {
            const config = {
                host: process.env.DB_HOST || 'localhost',
                port: parseInt(process.env.DB_PORT || '5432'),
                database: process.env.DB_NAME || 'encore_tasks',
                user: process.env.DB_USER || 'postgres',
                password: process.env.DB_PASSWORD || 'password',
                ssl: process.env.DB_SSL === 'true'
            };
            PostgreSQLAdapter.instance = new PostgreSQLAdapter(config);
        }
        return PostgreSQLAdapter.instance;
    }
}
// Экспорт экземпляра адаптера
let dbAdapter = null;
function getPostgreSQLAdapter() {
    if (!dbAdapter) {
        const config = {
            host: process.env.DB_HOST || 'localhost',
            port: parseInt(process.env.DB_PORT || '5432'),
            database: process.env.DB_NAME || 'encore_tasks',
            user: process.env.DB_USER || 'postgres',
            password: process.env.DB_PASSWORD || 'password',
            ssl: process.env.DB_SSL === 'true'
        };
        dbAdapter = new PostgreSQLAdapter(config);
    }
    return dbAdapter;
}
const __TURBOPACK__default__export__ = getPostgreSQLAdapter;
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
"[project]/src/lib/database-adapter.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname, a: __turbopack_async_module__ } = __turbopack_context__;
__turbopack_async_module__(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {
// =====================================================
// АДАПТЕР ДЛЯ РАБОТЫ С БАЗАМИ ДАННЫХ (ИСПРАВЛЕННЫЙ)
// =====================================================
__turbopack_context__.s({
    "DatabaseAdapter": (()=>DatabaseAdapter),
    "dbAdapter": (()=>dbAdapter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$postgresql$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/postgresql-adapter.ts [app-route] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$postgresql$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__
]);
([__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$postgresql$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__);
;
class DatabaseAdapter {
    static instance;
    currentDatabase = 'postgresql';
    isInitialized = false;
    postgresqlAdapter;
    initializationPromise = null;
    constructor(){
        this.postgresqlAdapter = __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$postgresql$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PostgreSQLAdapter"].getInstance();
        this.currentDatabase = 'postgresql';
    }
    static getInstance() {
        if (!DatabaseAdapter.instance) {
            DatabaseAdapter.instance = new DatabaseAdapter();
        }
        return DatabaseAdapter.instance;
    }
    /**
   * Инициализация адаптера
   */ async initialize() {
        if (this.isInitialized) {
            return;
        }
        if (this.initializationPromise) {
            return this.initializationPromise;
        }
        this.initializationPromise = this.performInitialization();
        return this.initializationPromise;
    }
    async performInitialization() {
        try {
            await this.postgresqlAdapter.initialize();
            this.isInitialized = true;
            console.log('✅ Database Adapter инициализирован с PostgreSQL');
        } catch (error) {
            console.error('❌ Ошибка инициализации Database Adapter:', error);
            this.initializationPromise = null;
            throw error;
        }
    }
    /**
   * Проверка инициализации перед выполнением операций
   */ async ensureInitialized() {
        if (!this.isInitialized) {
            await this.initialize();
        }
    }
    /**
   * Получение статуса базы данных
   */ async getDatabaseStatus() {
        const postgresql = await Promise.resolve(this.postgresqlAdapter.initialize()).then(()=>true).catch(()=>false);
        return {
            postgresql,
            current: this.currentDatabase
        };
    }
    /**
   * Получение текущей базы данных
   */ getCurrentDatabase() {
        return this.currentDatabase;
    }
    // =====================================================
    // ОПЕРАЦИИ С ПОЛЬЗОВАТЕЛЯМИ
    // =====================================================
    /**
   * Создание пользователя
   */ async createUser(userData) {
        await this.ensureInitialized();
        return await this.postgresqlAdapter.createUser(userData.email, userData.password, userData.name, userData.role || 'user');
    }
    /**
   * Получение пользователя по ID
   */ async getUserById(id) {
        await this.ensureInitialized();
        return await this.postgresqlAdapter.getUserById(id);
    }
    /**
   * Получение пользователя по email
   */ async getUserByEmail(email) {
        await this.ensureInitialized();
        return await this.postgresqlAdapter.getUserByEmail(email);
    }
    /**
   * Получение всех пользователей
   */ async getAllUsers() {
        await this.ensureInitialized();
        return await this.postgresqlAdapter.getAllUsers();
    }
    /**
   * Обновление пользователя
   */ async updateUser(id, updates) {
        await this.ensureInitialized();
        return await this.postgresqlAdapter.updateUser(id, updates);
    }
    /**
   * Удаление пользователя
   */ async deleteUser(id) {
        await this.ensureInitialized();
        return await this.postgresqlAdapter.deleteUser(id);
    }
    // =====================================================
    // ОПЕРАЦИИ С СЕССИЯМИ (ИСПРАВЛЕНО)
    // =====================================================
    /**
   * Создание сессии
   */ async createSession(sessionData) {
        await this.ensureInitialized();
        console.log('🔐 DatabaseAdapter: Создание сессии через PostgreSQL адаптер');
        console.log('🔐 SessionData:', {
            token: sessionData.token ? 'present' : 'missing',
            userId: sessionData.userId,
            expiresAt: sessionData.expiresAt
        });
        return await this.postgresqlAdapter.createSession(sessionData.token, sessionData.userId, sessionData.expiresAt);
    }
    /**
   * Получение сессии по токену
   */ async getSessionByToken(token) {
        await this.ensureInitialized();
        console.log('🔍 DatabaseAdapter: Поиск сессии по токену через PostgreSQL адаптер');
        const session = await this.postgresqlAdapter.getSessionByToken(token);
        console.log('📊 DatabaseAdapter: Результат поиска сессии:', session ? 'найдена' : 'не найдена');
        return session;
    }
    /**
   * Обновление активности сессии
   */ async updateSessionActivity(token) {
        await this.ensureInitialized();
        // Для PostgreSQL можно реализовать обновление времени последней активности
        return true;
    }
    /**
   * Удаление сессии
   */ async deleteSession(token) {
        await this.ensureInitialized();
        return await this.postgresqlAdapter.deleteSession(token);
    }
    // =====================================================
    // ОПЕРАЦИИ С ПРОЕКТАМИ
    // =====================================================
    /**
   * Создание проекта
   */ async createProject(projectData) {
        await this.ensureInitialized();
        const { name, description, createdBy, color } = projectData;
        return await this.postgresqlAdapter.createProject(name, description || '', createdBy, color);
    }
    /**
   * Получение проекта по ID
   */ async getProjectById(id) {
        await this.ensureInitialized();
        return await this.postgresqlAdapter.getProjectById(id);
    }
    /**
   * Получение всех проектов
   */ async getAllProjects() {
        await this.ensureInitialized();
        return await this.postgresqlAdapter.getAllProjects();
    }
    /**
   * Получение проектов пользователя
   */ async getUserProjects(userId) {
        await this.ensureInitialized();
        return await this.postgresqlAdapter.getUserProjects(userId);
    }
    /**
   * Получение проектов по ID создателя
   */ async getProjectsByCreatorId(creatorId) {
        await this.ensureInitialized();
        return await this.postgresqlAdapter.getUserProjects(creatorId);
    }
    /**
   * Проверка доступа к проекту
   */ async hasProjectAccess(userId, projectId) {
        await this.ensureInitialized();
        return await this.postgresqlAdapter.hasProjectAccess(userId.toString(), projectId);
    }
    // =====================================================
    // ОПЕРАЦИИ С ДОСКАМИ
    // =====================================================
    /**
   * Создание доски
   */ async createBoard(boardData) {
        await this.ensureInitialized();
        return await this.postgresqlAdapter.createBoard(boardData.name, boardData.description || '', boardData.projectId);
    }
    /**
   * Получение доски по ID
   */ async getBoardById(id) {
        await this.ensureInitialized();
        return await this.postgresqlAdapter.getBoardById(id);
    }
    /**
   * Получение досок проекта
   */ async getProjectBoards(projectId) {
        await this.ensureInitialized();
        return await this.postgresqlAdapter.getProjectBoards(projectId);
    }
    /**
   * Удаление доски
   */ async deleteBoard(id) {
        await this.ensureInitialized();
        return await this.postgresqlAdapter.deleteBoard(id);
    }
    // =====================================================
    // ОПЕРАЦИИ С КОЛОНКАМИ
    // =====================================================
    /**
   * Получение колонок доски
   */ async getBoardColumns(boardId) {
        await this.ensureInitialized();
        return await this.postgresqlAdapter.getBoardColumns(boardId);
    }
    /**
   * Создание колонки
   */ async createColumn(columnData) {
        await this.ensureInitialized();
        return await this.postgresqlAdapter.createColumn(columnData.name, columnData.boardId, columnData.position || 0);
    }
    // =====================================================
    // ОПЕРАЦИИ С ЗАДАЧАМИ
    // =====================================================
    /**
   * Создание задачи
   */ async createTask(taskData) {
        await this.ensureInitialized();
        return await this.postgresqlAdapter.createTask(taskData.title, taskData.description || '', taskData.columnId, taskData.assignedTo, taskData.priority || 'medium', taskData.position || 0);
    }
    /**
   * Получение задач колонки
   */ async getColumnTasks(columnId) {
        await this.ensureInitialized();
        return await this.postgresqlAdapter.getColumnTasks(columnId);
    }
    /**
   * Удаление задачи
   */ async deleteTask(id) {
        await this.ensureInitialized();
        return await this.postgresqlAdapter.deleteTask(id);
    }
    /**
   * Выполнение сырого SQL запроса (для совместимости с репозиториями)
   */ async query(sql, params) {
        await this.ensureInitialized();
        return await this.postgresqlAdapter.query(sql, params);
    }
}
const dbAdapter = DatabaseAdapter.getInstance();
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
"[project]/src/app/api/auth/login/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname, a: __turbopack_async_module__ } = __turbopack_context__;
__turbopack_async_module__(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {
__turbopack_context__.s({
    "POST": (()=>POST)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bcryptjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bcryptjs/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jsonwebtoken/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/database-adapter.ts [app-route] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__
]);
([__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__);
;
;
;
;
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';
async function POST(request) {
    try {
        const { email, password } = await request.json();
        if (!email || !password) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Email и пароль обязательны'
            }, {
                status: 400
            });
        }
        // Поиск пользователя по email
        console.log('🔍 Looking up user by email:', email);
        const user = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["dbAdapter"].getUserByEmail(email);
        console.log('👤 User found:', user ? 'YES' : 'NO');
        if (user) {
            console.log('👤 User details:', {
                id: user.id,
                email: user.email,
                approval_status: user.approval_status,
                has_password: !!user.password_hash
            });
        }
        // Временно отключена проверка approval_status для решения проблем с входом
        if (!user) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Неверный email или пароль'
            }, {
                status: 401
            });
        }
        // Закомментировано: || user.approval_status !== 'approved'
        // Это позволяет пользователям входить независимо от статуса одобрения
        // Проверка пароля
        console.log('🔐 Checking password for user:', user.email);
        console.log('🔐 Has password hash:', !!user.password_hash);
        const isValidPassword = user.password_hash ? await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bcryptjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].compare(password, user.password_hash) : false;
        console.log('🔐 Password valid:', isValidPassword);
        if (!isValidPassword) {
            console.log('❌ Password validation failed');
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Неверный email или пароль'
            }, {
                status: 401
            });
        }
        console.log('✅ Password validation successful');
        // Создание сессии с правильной типизацией
        const sessionToken = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].sign({
            userId: user.id,
            email: user.email
        }, JWT_SECRET, {
            expiresIn: '7d'
        });
        const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 дней
        await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["dbAdapter"].createSession({
            userId: user.id,
            token: sessionToken,
            expiresAt: expiresAt
        });
        // TODO: Добавить обновление времени последнего входа после добавления колонки last_login_at
        // await databaseAdapter.updateUser(user.id, {
        //   last_login_at: new Date().toISOString()
        // });
        const userResponse = {
            id: user.id,
            name: user.name,
            email: user.email,
            role: user.role,
            approval_status: user.approval_status || 'approved',
            status: user.is_active ? 'active' : 'inactive',
            avatar: user.avatar || null,
            createdAt: user.created_at,
            updatedAt: user.updated_at
        };
        const response = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            message: 'Успешная авторизация',
            user: userResponse,
            token: sessionToken
        });
        // Устанавливаем токен в cookies для автоматической аутентификации
        response.cookies.set('auth-token', sessionToken, {
            httpOnly: true,
            secure: ("TURBOPACK compile-time value", "development") === 'production',
            sameSite: 'strict',
            path: '/',
            maxAge: 7 * 24 * 60 * 60 * 1000 // 7 дней - соответствует времени жизни JWT
        });
        // Также устанавливаем обычный cookie для фронтенда
        response.cookies.set('auth-token-client', sessionToken, {
            httpOnly: false,
            secure: ("TURBOPACK compile-time value", "development") === 'production',
            sameSite: 'strict',
            path: '/',
            maxAge: 7 * 24 * 60 * 60 * 1000 // 7 дней - соответствует времени жизни JWT
        });
        return response;
    } catch (error) {
        console.error('Login error:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Внутренняя ошибка сервера'
        }, {
            status: 500
        });
    }
}
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__e8cef74f._.js.map