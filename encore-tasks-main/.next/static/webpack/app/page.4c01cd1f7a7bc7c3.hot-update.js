"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/refactored/business/services/project.service.client.ts":
/*!********************************************************************!*\
  !*** ./src/refactored/business/services/project.service.client.ts ***!
  \********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientProjectService: () => (/* binding */ ClientProjectService),\n/* harmony export */   clientProjectService: () => (/* binding */ clientProjectService)\n/* harmony export */ });\nclass ClientProjectService {\n    async getProjects() {\n        let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        var _filters_pagination, _filters_pagination1;\n        const params = new URLSearchParams();\n        if (filters.status) params.append('status', filters.status);\n        if (filters.search) params.append('query', filters.search);\n        if (filters.sortBy) params.append('sortBy', filters.sortBy);\n        if (filters.sortOrder) params.append('sortOrder', filters.sortOrder);\n        if (filters.showArchived !== undefined) params.append('showArchived', filters.showArchived.toString());\n        if ((_filters_pagination = filters.pagination) === null || _filters_pagination === void 0 ? void 0 : _filters_pagination.page) params.append('page', filters.pagination.page.toString());\n        if ((_filters_pagination1 = filters.pagination) === null || _filters_pagination1 === void 0 ? void 0 : _filters_pagination1.limit) params.append('limit', filters.pagination.limit.toString());\n        const response = await fetch(\"\".concat(this.baseUrl, \"?\").concat(params));\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch projects: \".concat(response.statusText));\n        }\n        return response.json();\n    }\n    async getById(id, userId) {\n        const response = await fetch(\"\".concat(this.baseUrl, \"/\").concat(id));\n        if (!response.ok) {\n            if (response.status === 404) throw new Error('Project not found');\n            throw new Error(\"Failed to fetch project: \".concat(response.statusText));\n        }\n        return response.json();\n    }\n    async create(projectData, userId) {\n        const response = await fetch(this.baseUrl, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                ...projectData,\n                userId\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"Failed to create project: \".concat(response.statusText));\n        }\n        return response.json();\n    }\n    async update(id, updates, userId) {\n        const response = await fetch(\"\".concat(this.baseUrl, \"/\").concat(id), {\n            method: 'PUT',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                ...updates,\n                userId\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"Failed to update project: \".concat(response.statusText));\n        }\n        return response.json();\n    }\n    async delete(id, userId) {\n        const response = await fetch(\"\".concat(this.baseUrl, \"/\").concat(id), {\n            method: 'DELETE',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                userId\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"Failed to delete project: \".concat(response.statusText));\n        }\n    }\n    async archive(id, userId) {\n        const response = await fetch(\"\".concat(this.baseUrl, \"/\").concat(id, \"/archive\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                userId\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"Failed to archive project: \".concat(response.statusText));\n        }\n        return response.json();\n    }\n    async restore(id, userId) {\n        const response = await fetch(\"\".concat(this.baseUrl, \"/\").concat(id, \"/restore\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                userId\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"Failed to restore project: \".concat(response.statusText));\n        }\n        return response.json();\n    }\n    async getByUserId(userId, filters) {\n        const params = new URLSearchParams();\n        if (filters === null || filters === void 0 ? void 0 : filters.statuses) params.append('statuses', filters.statuses.join(','));\n        if (filters === null || filters === void 0 ? void 0 : filters.query) params.append('query', filters.query);\n        const response = await fetch(\"\".concat(this.baseUrl, \"?\").concat(params));\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch user projects: \".concat(response.statusText));\n        }\n        const result = await response.json();\n        return result.data || result;\n    }\n    async getProjectMembers(projectId) {\n        const response = await fetch(\"\".concat(this.baseUrl, \"/\").concat(projectId, \"/members\"));\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch project members: \".concat(response.statusText));\n        }\n        return response.json();\n    }\n    async addMember(projectId, memberData, userId) {\n        const response = await fetch(\"\".concat(this.baseUrl, \"/\").concat(projectId, \"/members\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                ...memberData,\n                userId\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"Failed to add project member: \".concat(response.statusText));\n        }\n    }\n    async removeMember(projectId, memberId, userId) {\n        const response = await fetch(\"\".concat(this.baseUrl, \"/\").concat(projectId, \"/members/\").concat(memberId), {\n            method: 'DELETE',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                userId\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"Failed to remove project member: \".concat(response.statusText));\n        }\n    }\n    async duplicate(id, newName, userId) {\n        const response = await fetch(\"\".concat(this.baseUrl, \"/\").concat(id, \"/duplicate\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                newName,\n                userId\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"Failed to duplicate project: \".concat(response.statusText));\n        }\n        return response.json();\n    }\n    async updateMemberRole(projectId, memberId, role, userId) {\n        const response = await fetch(\"\".concat(this.baseUrl, \"/\").concat(projectId, \"/members/\").concat(memberId, \"/role\"), {\n            method: 'PUT',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                role,\n                userId\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"Failed to update member role: \".concat(response.statusText));\n        }\n    }\n    async getStatistics(id, userId) {\n        const response = await fetch(\"\".concat(this.baseUrl, \"/\").concat(id, \"/statistics\"), {\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        });\n        if (!response.ok) {\n            throw new Error(\"Failed to get project statistics: \".concat(response.statusText));\n        }\n        return response.json();\n    }\n    async checkPermissions(projectId, userId, permission) {\n        const response = await fetch(\"\".concat(this.baseUrl, \"/\").concat(projectId, \"/permissions/\").concat(userId, \"/\").concat(permission));\n        if (!response.ok) {\n            throw new Error(\"Failed to check permissions: \".concat(response.statusText));\n        }\n        const result = await response.json();\n        return result.hasPermission || false;\n    }\n    constructor(){\n        this.baseUrl = '/api/projects';\n    }\n}\nconst clientProjectService = new ClientProjectService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9yZWZhY3RvcmVkL2J1c2luZXNzL3NlcnZpY2VzL3Byb2plY3Quc2VydmljZS5jbGllbnQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFzQk8sTUFBTUE7SUFHWCxNQUFNQyxjQUErRTtZQUFuRUMsVUFBQUEsaUVBQTBCLENBQUM7WUFRdkNBLHFCQUNBQTtRQVJKLE1BQU1DLFNBQVMsSUFBSUM7UUFFbkIsSUFBSUYsUUFBUUcsTUFBTSxFQUFFRixPQUFPRyxNQUFNLENBQUMsVUFBVUosUUFBUUcsTUFBTTtRQUMxRCxJQUFJSCxRQUFRSyxNQUFNLEVBQUVKLE9BQU9HLE1BQU0sQ0FBQyxTQUFTSixRQUFRSyxNQUFNO1FBQ3pELElBQUlMLFFBQVFNLE1BQU0sRUFBRUwsT0FBT0csTUFBTSxDQUFDLFVBQVVKLFFBQVFNLE1BQU07UUFDMUQsSUFBSU4sUUFBUU8sU0FBUyxFQUFFTixPQUFPRyxNQUFNLENBQUMsYUFBYUosUUFBUU8sU0FBUztRQUNuRSxJQUFJUCxRQUFRUSxZQUFZLEtBQUtDLFdBQVdSLE9BQU9HLE1BQU0sQ0FBQyxnQkFBZ0JKLFFBQVFRLFlBQVksQ0FBQ0UsUUFBUTtRQUNuRyxLQUFJVixzQkFBQUEsUUFBUVcsVUFBVSxjQUFsQlgsMENBQUFBLG9CQUFvQlksSUFBSSxFQUFFWCxPQUFPRyxNQUFNLENBQUMsUUFBUUosUUFBUVcsVUFBVSxDQUFDQyxJQUFJLENBQUNGLFFBQVE7UUFDcEYsS0FBSVYsdUJBQUFBLFFBQVFXLFVBQVUsY0FBbEJYLDJDQUFBQSxxQkFBb0JhLEtBQUssRUFBRVosT0FBT0csTUFBTSxDQUFDLFNBQVNKLFFBQVFXLFVBQVUsQ0FBQ0UsS0FBSyxDQUFDSCxRQUFRO1FBRXZGLE1BQU1JLFdBQVcsTUFBTUMsTUFBTSxHQUFtQmQsT0FBaEIsSUFBSSxDQUFDZSxPQUFPLEVBQUMsS0FBVSxPQUFQZjtRQUNoRCxJQUFJLENBQUNhLFNBQVNHLEVBQUUsRUFBRTtZQUNoQixNQUFNLElBQUlDLE1B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QUFNLElBQUlDLE1BQU0sZ0NBQW9ELE9BQXBCSixTQUFTSyxVQUFVO1FBQ3JFO1FBRUEsTUFBTXFCLFNBQVMsTUFBTTFCLFNBQVNNLElBQUk7UUFDbEMsT0FBT29CLE9BQU9lLGFBQWEsSUFBSTtJQUNqQzs7YUFyTlF2QyxVQUFVOztBQXNOcEI7QUFFTyxNQUFNd0MsdUJBQXVCLElBQUkxRCx1QkFBdUIiLCJzb3VyY2VzIjpbIkU6XFxQcm9qZWN0c1xcZW5jb3JlLXRhc2tzXFxlbmNvcmUtdGFza3MtbWFpblxcc3JjXFxyZWZhY3RvcmVkXFxidXNpbmVzc1xcc2VydmljZXNcXHByb2plY3Quc2VydmljZS5jbGllbnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgUHJvamVjdCxcbiAgQ3JlYXRlUHJvamVjdERhdGEsXG4gIFVwZGF0ZVByb2plY3REYXRhLFxuICBQcm9qZWN0U3RhdHVzLFxuICBQcm9qZWN0U29ydEJ5LFxuICBTb3J0T3JkZXIsXG4gIFBhZ2luYXRpb25QYXJhbXMsXG4gIFBhZ2luYXRlZFJlc3BvbnNlLFxuICBTZWFyY2hGaWx0ZXJzXG59IGZyb20gJy4uLy4uL2RhdGEvdHlwZXMnO1xuaW1wb3J0IHsgSVByb2plY3RTZXJ2aWNlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvamVjdEZpbHRlcnMge1xuICBzdGF0dXM/OiBQcm9qZWN0U3RhdHVzO1xuICBzZWFyY2g/OiBzdHJpbmc7XG4gIHNvcnRCeT86IFByb2plY3RTb3J0Qnk7XG4gIHNvcnRPcmRlcj86IFNvcnRPcmRlcjtcbiAgc2hvd0FyY2hpdmVkPzogYm9vbGVhbjtcbiAgcGFnaW5hdGlvbj86IFBhZ2luYXRpb25QYXJhbXM7XG59XG5cbmV4cG9ydCBjbGFzcyBDbGllbnRQcm9qZWN0U2VydmljZSBpbXBsZW1lbnRzIElQcm9qZWN0U2VydmljZSB7XG4gIHByaXZhdGUgYmFzZVVybCA9ICcvYXBpL3Byb2plY3RzJztcblxuICBhc3luYyBnZXRQcm9qZWN0cyhmaWx0ZXJzOiBQcm9qZWN0RmlsdGVycyA9IHt9KTogUHJvbWlzZTxQYWdpbmF0ZWRSZXNwb25zZTxQcm9qZWN0Pj4ge1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBcbiAgICBpZiAoZmlsdGVycy5zdGF0dXMpIHBhcmFtcy5hcHBlbmQoJ3N0YXR1cycsIGZpbHRlcnMuc3RhdHVzKTtcbiAgICBpZiAoZmlsdGVycy5zZWFyY2gpIHBhcmFtcy5hcHBlbmQoJ3F1ZXJ5JywgZmlsdGVycy5zZWFyY2gpO1xuICAgIGlmIChmaWx0ZXJzLnNvcnRCeSkgcGFyYW1zLmFwcGVuZCgnc29ydEJ5JywgZmlsdGVycy5zb3J0QnkpO1xuICAgIGlmIChmaWx0ZXJzLnNvcnRPcmRlcikgcGFyYW1zLmFwcGVuZCgnc29ydE9yZGVyJywgZmlsdGVycy5zb3J0T3JkZXIpO1xuICAgIGlmIChmaWx0ZXJzLnNob3dBcmNoaXZlZCAhPT0gdW5kZWZpbmVkKSBwYXJhbXMuYXBwZW5kKCdzaG93QXJjaGl2ZWQnLCBmaWx0ZXJzLnNob3dBcmNoaXZlZC50b1N0cmluZygpKTtcbiAgICBpZiAoZmlsdGVycy5wYWdpbmF0aW9uPy5wYWdlKSBwYXJhbXMuYXBwZW5kKCdwYWdlJywgZmlsdGVycy5wYWdpbmF0aW9uLnBhZ2UudG9TdHJpbmcoKSk7XG4gICAgaWYgKGZpbHRlcnMucGFnaW5hdGlvbj8ubGltaXQpIHBhcmFtcy5hcHBlbmQoJ2xpbWl0JywgZmlsdGVycy5wYWdpbmF0aW9uLmxpbWl0LnRvU3RyaW5nKCkpO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9PyR7cGFyYW1zfWApO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIHByb2plY3RzOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gIH1cblxuICBhc3luYyBnZXRCeUlkKGlkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxQcm9qZWN0PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9LyR7aWR9YCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3Qgbm90IGZvdW5kJyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBwcm9qZWN0OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gIH1cblxuICBhc3luYyBjcmVhdGUocHJvamVjdERhdGE6IE9taXQ8UHJvamVjdCwgJ2lkJyB8ICdjcmVhdGVkQXQnIHwgJ3VwZGF0ZWRBdCcgfCAnbWVtYmVycycgfCAnc3RhdGlzdGljcyc+LCB1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8UHJvamVjdD4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGhpcy5iYXNlVXJsLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IC4uLnByb2plY3REYXRhLCB1c2VySWQgfSksXG4gICAgfSk7XG4gICAgXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIHByb2plY3Q6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZShpZDogc3RyaW5nLCB1cGRhdGVzOiBQYXJ0aWFsPFByb2plY3Q+LCB1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8UHJvamVjdD4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS8ke2lkfWAsIHtcbiAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyAuLi51cGRhdGVzLCB1c2VySWQgfSksXG4gICAgfSk7XG4gICAgXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gdXBkYXRlIHByb2plY3Q6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgfVxuXG4gIGFzeW5jIGRlbGV0ZShpZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS8ke2lkfWAsIHtcbiAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB1c2VySWQgfSksXG4gICAgfSk7XG4gICAgXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZGVsZXRlIHByb2plY3Q6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBhcmNoaXZlKGlkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxQcm9qZWN0PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9LyR7aWR9L2FyY2hpdmVgLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHVzZXJJZCB9KSxcbiAgICB9KTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBhcmNoaXZlIHByb2plY3Q6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgfVxuXG4gIGFzeW5jIHJlc3RvcmUoaWQ6IHN0cmluZywgdXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPFByb2plY3Q+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0vJHtpZH0vcmVzdG9yZWAsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdXNlcklkIH0pLFxuICAgIH0pO1xuICAgIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHJlc3RvcmUgcHJvamVjdDogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICB9XG5cbiAgYXN5bmMgZ2V0QnlVc2VySWQodXNlcklkOiBzdHJpbmcsIGZpbHRlcnM/OiBTZWFyY2hGaWx0ZXJzKTogUHJvbWlzZTxQcm9qZWN0W10+IHtcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgaWYgKGZpbHRlcnM/LnN0YXR1c2VzKSBwYXJhbXMuYXBwZW5kKCdzdGF0dXNlcycsIGZpbHRlcnMuc3RhdHVzZXMuam9pbignLCcpKTtcbiAgICBpZiAoZmlsdGVycz8ucXVlcnkpIHBhcmFtcy5hcHBlbmQoJ3F1ZXJ5JywgZmlsdGVycy5xdWVyeSk7XG4gICAgXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9PyR7cGFyYW1zfWApO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIHVzZXIgcHJvamVjdHM6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIHJldHVybiByZXN1bHQuZGF0YSB8fCByZXN1bHQ7XG4gIH1cblxuICBhc3luYyBnZXRQcm9qZWN0TWVtYmVycyhwcm9qZWN0SWQ6IHN0cmluZyk6IFByb21pc2U8dW5rbm93bltdPiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9LyR7cHJvamVjdElkfS9tZW1iZXJzYCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggcHJvamVjdCBtZW1iZXJzOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gIH1cblxuICBhc3luYyBhZGRNZW1iZXIocHJvamVjdElkOiBzdHJpbmcsIG1lbWJlckRhdGE6IE9taXQ8UHJvamVjdFsnbWVtYmVycyddWzBdLCAnam9pbmVkQXQnPiwgdXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0vJHtwcm9qZWN0SWR9L21lbWJlcnNgLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IC4uLm1lbWJlckRhdGEsIHVzZXJJZCB9KSxcbiAgICB9KTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBhZGQgcHJvamVjdCBtZW1iZXI6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyByZW1vdmVNZW1iZXIocHJvamVjdElkOiBzdHJpbmcsIG1lbWJlcklkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9LyR7cHJvamVjdElkfS9tZW1iZXJzLyR7bWVtYmVySWR9YCwge1xuICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHVzZXJJZCB9KSxcbiAgICB9KTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byByZW1vdmUgcHJvamVjdCBtZW1iZXI6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBkdXBsaWNhdGUoaWQ6IHN0cmluZywgbmV3TmFtZTogc3RyaW5nLCB1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8UHJvamVjdD4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS8ke2lkfS9kdXBsaWNhdGVgLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IG5ld05hbWUsIHVzZXJJZCB9KSxcbiAgICB9KTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkdXBsaWNhdGUgcHJvamVjdDogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlTWVtYmVyUm9sZShwcm9qZWN0SWQ6IHN0cmluZywgbWVtYmVySWQ6IHN0cmluZywgcm9sZTogUHJvamVjdFsnbWVtYmVycyddWzBdWydyb2xlJ10sIHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9LyR7cHJvamVjdElkfS9tZW1iZXJzLyR7bWVtYmVySWR9L3JvbGVgLCB7XG4gICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcm9sZSwgdXNlcklkIH0pLFxuICAgIH0pO1xuICAgIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHVwZGF0ZSBtZW1iZXIgcm9sZTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFN0YXRpc3RpY3MoaWQ6IHN0cmluZywgdXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPFByb2plY3RbJ3N0YXRpc3RpY3MnXT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS8ke2lkfS9zdGF0aXN0aWNzYCwge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgcHJvamVjdCBzdGF0aXN0aWNzOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gIH1cblxuICBhc3luYyBjaGVja1Blcm1pc3Npb25zKHByb2plY3RJZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZywgcGVybWlzc2lvbjogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9LyR7cHJvamVjdElkfS9wZXJtaXNzaW9ucy8ke3VzZXJJZH0vJHtwZXJtaXNzaW9ufWApO1xuICAgIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNoZWNrIHBlcm1pc3Npb25zOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4gcmVzdWx0Lmhhc1Blcm1pc3Npb24gfHwgZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNsaWVudFByb2plY3RTZXJ2aWNlID0gbmV3IENsaWVudFByb2plY3RTZXJ2aWNlKCk7Il0sIm5hbWVzIjpbIkNsaWVudFByb2plY3RTZXJ2aWNlIiwiZ2V0UHJvamVjdHMiLCJmaWx0ZXJzIiwicGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwic3RhdHVzIiwiYXBwZW5kIiwic2VhcmNoIiwic29ydEJ5Iiwic29ydE9yZGVyIiwic2hvd0FyY2hpdmVkIiwidW5kZWZpbmVkIiwidG9TdHJpbmciLCJwYWdpbmF0aW9uIiwicGFnZSIsImxpbWl0IiwicmVzcG9uc2UiLCJmZXRjaCIsImJhc2VVcmwiLCJvayIsIkVycm9yIiwic3RhdHVzVGV4dCIsImpzb24iLCJnZXRCeUlkIiwiaWQiLCJ1c2VySWQiLCJjcmVhdGUiLCJwcm9qZWN0RGF0YSIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInVwZGF0ZSIsInVwZGF0ZXMiLCJkZWxldGUiLCJhcmNoaXZlIiwicmVzdG9yZSIsImdldEJ5VXNlcklkIiwic3RhdHVzZXMiLCJqb2luIiwicXVlcnkiLCJyZXN1bHQiLCJkYXRhIiwiZ2V0UHJvamVjdE1lbWJlcnMiLCJwcm9qZWN0SWQiLCJhZGRNZW1iZXIiLCJtZW1iZXJEYXRhIiwicmVtb3ZlTWVtYmVyIiwibWVtYmVySWQiLCJkdXBsaWNhdGUiLCJuZXdOYW1lIiwidXBkYXRlTWVtYmVyUm9sZSIsInJvbGUiLCJnZXRTdGF0aXN0aWNzIiwiY2hlY2tQZXJtaXNzaW9ucyIsInBlcm1pc3Npb24iLCJoYXNQZXJtaXNzaW9uIiwiY2xpZW50UHJvamVjdFNlcnZpY2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/refactored/business/services/project.service.client.ts\n"));

/***/ })

});