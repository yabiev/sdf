module.exports = {

"[project]/.next-internal/server/app/api/auth/me/route/actions.js [app-rsc] (server actions loader, ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/pg [external] (pg, esm_import)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname, a: __turbopack_async_module__ } = __turbopack_context__;
__turbopack_async_module__(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {
const mod = await __turbopack_context__.y("pg");

__turbopack_context__.n(mod);
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, true);}),
"[project]/src/lib/postgresql-adapter.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname, a: __turbopack_async_module__ } = __turbopack_context__;
__turbopack_async_module__(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {
__turbopack_context__.s({
    "PostgreSQLAdapter": (()=>PostgreSQLAdapter),
    "default": (()=>__TURBOPACK__default__export__),
    "getPostgreSQLAdapter": (()=>getPostgreSQLAdapter)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$29$__ = __turbopack_context__.i("[externals]/pg [external] (pg, esm_import)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bcryptjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bcryptjs/index.js [app-route] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$29$__
]);
([__TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__);
;
;
class PostgreSQLAdapter {
    static instance = null;
    pool;
    isInitialized = false;
    constructor(config){
        this.pool = new __TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$29$__["Pool"]({
            host: config.host,
            port: config.port,
            database: config.database,
            user: config.user,
            password: config.password,
            ssl: config.ssl ? {
                rejectUnauthorized: false
            } : false,
            max: 20,
            idleTimeoutMillis: 30000,
            connectionTimeoutMillis: 2000
        });
    }
    // Инициализация базы данных
    async initialize() {
        if (this.isInitialized) return;
        try {
            const client = await this.pool.connect();
            // Проверяем подключение
            await client.query('SELECT NOW()');
            console.log('✅ PostgreSQL подключение установлено');
            client.release();
            this.isInitialized = true;
        } catch (error) {
            console.error('❌ Ошибка подключения к PostgreSQL:', error);
            throw error;
        }
    }
    // Закрытие пула соединений
    async close() {
        await this.pool.end();
        this.isInitialized = false;
    }
    // Получение клиента для транзакций
    async getClient() {
        return await this.pool.connect();
    }
    // Выполнение запроса
    async query(text, params) {
        const client = await this.pool.connect();
        try {
            console.log('SQL Query:', text);
            console.log('SQL Params:', params);
            const result = await client.query(text, params);
            return result;
        } finally{
            client.release();
        }
    }
    // === МЕТОДЫ ДЛЯ ПОЛЬЗОВАТЕЛЕЙ ===
    async createUser(email, password, name, role = 'user') {
        const hashedPassword = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bcryptjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].hash(password, 12);
        const result = await this.query(`INSERT INTO users (email, password_hash, name, role, approval_status) 
       VALUES ($1, $2, $3, $4, $5) 
       RETURNING *`, [
            email,
            hashedPassword,
            name,
            role,
            'pending'
        ]);
        return result.rows[0];
    }
    async getUserByEmail(email) {
        const result = await this.query('SELECT * FROM users WHERE email = $1 AND deleted_at IS NULL', [
            email
        ]);
        return result.rows[0] || null;
    }
    async getUserById(id) {
        const result = await this.query('SELECT * FROM users WHERE id = $1 AND deleted_at IS NULL', [
            id
        ]);
        const row = result.rows[0];
        if (!row) return null;
        // Маппинг полей базы данных в User интерфейс
        return {
            id: row.id,
            userId: row.id,
            name: row.name,
            email: row.email,
            role: row.role,
            status: row.is_active ? 'active' : 'inactive',
            approval_status: row.approval_status,
            avatar: row.avatar,
            createdAt: row.created_at,
            updatedAt: row.updated_at,
            lastLoginAt: row.last_login_at,
            is_active: row.is_active,
            created_at: row.created_at,
            updated_at: row.updated_at,
            last_login_at: row.last_login_at
        };
    }
    async updateUser(id, updates) {
        const fields = Object.keys(updates).filter((key)=>key !== 'id');
        const values = fields.map((field)=>updates[field]);
        const setClause = fields.map((field, index)=>`${field} = $${index + 2}`).join(', ');
        if (fields.length === 0) {
            return await this.getUserById(id);
        }
        const result = await this.query(`UPDATE users SET ${setClause} WHERE id = $1 RETURNING *`, [
            id,
            ...values
        ]);
        return result.rows[0] || null;
    }
    async getAllUsers() {
        const result = await this.query('SELECT * FROM users WHERE deleted_at IS NULL ORDER BY created_at DESC');
        return result.rows;
    }
    async deleteUser(id) {
        const result = await this.query('UPDATE users SET deleted_at = CURRENT_TIMESTAMP WHERE id = $1', [
            id
        ]);
        return result.rowCount > 0;
    }
    // === МЕТОДЫ ДЛЯ ПРОЕКТОВ ===
    async createProject(name, description, ownerId, color) {
        const result = await this.query(`INSERT INTO projects (name, description, creator_id, color)
     VALUES ($1, $2, $3, $4) RETURNING *`, [
            name,
            description,
            ownerId,
            color || '#3B82F6'
        ]);
        return result.rows[0];
    }
    async getProjectById(id) {
        const result = await this.query('SELECT * FROM projects WHERE id = $1 AND deleted_at IS NULL', [
            id
        ]);
        return result.rows[0] || null;
    }
    async getProjectsByUserId(userId) {
        const result = await this.query(`SELECT DISTINCT p.* FROM projects p 
       LEFT JOIN project_members pm ON p.id = pm.project_id 
       WHERE (p.creator_id = $1 OR pm.user_id = $1) AND p.deleted_at IS NULL 
       ORDER BY p.created_at DESC`, [
            userId
        ]);
        return result.rows;
    }
    async getAllProjects() {
        const result = await this.query('SELECT * FROM projects WHERE deleted_at IS NULL ORDER BY created_at DESC');
        return result.rows;
    }
    async updateProject(id, updates) {
        const fields = Object.keys(updates).filter((key)=>key !== 'id');
        const values = fields.map((field)=>updates[field]);
        const setClause = fields.map((field, index)=>`${field} = $${index + 2}`).join(', ');
        if (fields.length === 0) {
            return await this.getProjectById(id);
        }
        const result = await this.query(`UPDATE projects SET ${setClause} WHERE id = $1 RETURNING *`, [
            id,
            ...values
        ]);
        return result.rows[0] || null;
    }
    async deleteProject(id) {
        const result = await this.query('UPDATE projects SET deleted_at = CURRENT_TIMESTAMP WHERE id = $1', [
            id
        ]);
        return result.rowCount > 0;
    }
    async hasProjectAccess(userId, projectId) {
        try {
            // Проверяем, является ли пользователь владельцем проекта
            const ownerResult = await this.query('SELECT creator_id FROM projects WHERE id = $1 AND deleted_at IS NULL', [
                projectId
            ]);
            if (ownerResult.rows.length === 0) {
                return false; // Проект не найден
            }
            const projectOwner = ownerResult.rows[0].creator_id;
            if (projectOwner === userId) {
                return true; // Пользователь является владельцем
            }
            // Проверяем членство в проекте
            const memberResult = await this.query('SELECT 1 FROM project_members WHERE project_id = $1 AND user_id = $2', [
                projectId,
                userId
            ]);
            return memberResult.rows.length > 0;
        } catch (error) {
            console.error('Error checking project access:', error);
            return false;
        }
    }
    // === МЕТОДЫ ДЛЯ ДОСОК ===
    async createBoard(name, description, projectId) {
        const result = await this.query(`INSERT INTO boards (name, project_id) 
       VALUES ($1, $2) 
       RETURNING *`, [
            name,
            projectId
        ]);
        return result.rows[0];
    }
    async getBoardById(id) {
        const result = await this.query('SELECT * FROM boards WHERE id = $1 AND deleted_at IS NULL', [
            id
        ]);
        return result.rows[0] || null;
    }
    async getBoardsByProjectId(projectId) {
        const result = await this.query('SELECT * FROM boards WHERE project_id = $1 AND deleted_at IS NULL ORDER BY position, created_at', [
            projectId
        ]);
        return result.rows;
    }
    async updateBoard(id, updates) {
        const fields = Object.keys(updates).filter((key)=>key !== 'id');
        const values = fields.map((field)=>updates[field]);
        const setClause = fields.map((field, index)=>`${field} = $${index + 2}`).join(', ');
        if (fields.length === 0) {
            return await this.getBoardById(id);
        }
        const result = await this.query(`UPDATE boards SET ${setClause} WHERE id = $1 RETURNING *`, [
            id,
            ...values
        ]);
        return result.rows[0] || null;
    }
    async deleteBoard(id) {
        const result = await this.query('UPDATE boards SET deleted_at = CURRENT_TIMESTAMP WHERE id = $1', [
            id
        ]);
        return result.rowCount > 0;
    }
    // === МЕТОДЫ ДЛЯ КОЛОНОК ===
    async createColumn(name, boardId, position, color) {
        const result = await this.query(`INSERT INTO columns (title, board_id, position, color) 
       VALUES ($1, $2, $3, $4) 
       RETURNING *`, [
            name,
            boardId,
            position || 0,
            color || '#6B7280'
        ]);
        return result.rows[0];
    }
    async getColumnById(id) {
        const result = await this.query('SELECT * FROM columns WHERE id = $1 AND deleted_at IS NULL', [
            id
        ]);
        return result.rows[0] || null;
    }
    async getColumnsByBoardId(boardId) {
        const result = await this.query('SELECT * FROM columns WHERE board_id = $1 AND deleted_at IS NULL ORDER BY position, created_at', [
            boardId
        ]);
        return result.rows;
    }
    async updateColumn(id, updates) {
        const fields = Object.keys(updates).filter((key)=>key !== 'id');
        const values = fields.map((field)=>updates[field]);
        const setClause = fields.map((field, index)=>`${field} = $${index + 2}`).join(', ');
        if (fields.length === 0) {
            return await this.getColumnById(id);
        }
        const result = await this.query(`UPDATE columns SET ${setClause} WHERE id = $1 RETURNING *`, [
            id,
            ...values
        ]);
        return result.rows[0] || null;
    }
    async deleteColumn(id) {
        const result = await this.query('UPDATE columns SET deleted_at = CURRENT_TIMESTAMP WHERE id = $1', [
            id
        ]);
        return result.rowCount > 0;
    }
    // === МЕТОДЫ ДЛЯ ЗАДАЧ ===
    async createTask(taskData) {
        const { title, description, status = 'todo', priority = 'medium', project_id, board_id, column_id, assignee_id, reporter_id, position = 0 } = taskData;
        const result = await this.query(`INSERT INTO tasks (title, description, status, priority, project_id, board_id, column_id, assignee_id, reporter_id, position) 
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) 
       RETURNING *`, [
            title,
            description,
            status,
            priority,
            project_id,
            board_id,
            column_id,
            assignee_id,
            reporter_id,
            position
        ]);
        return result.rows[0];
    }
    async getTaskById(id) {
        const result = await this.query('SELECT * FROM tasks WHERE id = $1 AND deleted_at IS NULL', [
            id
        ]);
        return result.rows[0] || null;
    }
    async getTasksByProjectId(projectId) {
        const result = await this.query('SELECT * FROM tasks WHERE project_id = $1 AND deleted_at IS NULL ORDER BY position, created_at', [
            projectId
        ]);
        return result.rows;
    }
    async getTasksByColumnId(columnId) {
        const result = await this.query('SELECT * FROM tasks WHERE column_id = $1 AND deleted_at IS NULL ORDER BY position, created_at', [
            columnId
        ]);
        return result.rows;
    }
    async updateTask(id, updates) {
        const fields = Object.keys(updates).filter((key)=>key !== 'id');
        const values = fields.map((field)=>updates[field]);
        const setClause = fields.map((field, index)=>`${field} = $${index + 2}`).join(', ');
        if (fields.length === 0) {
            return await this.getTaskById(id);
        }
        const result = await this.query(`UPDATE tasks SET ${setClause} WHERE id = $1 RETURNING *`, [
            id,
            ...values
        ]);
        return result.rows[0] || null;
    }
    async deleteTask(id) {
        const result = await this.query('UPDATE tasks SET deleted_at = CURRENT_TIMESTAMP WHERE id = $1', [
            id
        ]);
        return result.rowCount > 0;
    }
    // === МЕТОДЫ ДЛЯ СЕССИЙ ===
    async createSession(sessionToken, userId, expiresAt) {
        const result = await this.query(`INSERT INTO user_sessions (session_token, user_id, expires_at)
     VALUES ($1, $2, $3)
     RETURNING *`, [
            sessionToken,
            userId,
            expiresAt
        ]);
        const row = result.rows[0];
        return {
            id: row.id,
            userId: row.user_id,
            token: row.session_token,
            expiresAt: new Date(row.expires_at),
            isActive: true,
            userAgent: row.user_agent,
            ipAddress: row.ip_address,
            lastActivityAt: new Date(row.last_activity_at || row.created_at),
            createdAt: new Date(row.created_at),
            updatedAt: new Date(row.updated_at || row.created_at)
        };
    }
    async getSessionByToken(sessionToken) {
        const result = await this.query('SELECT * FROM user_sessions WHERE session_token = $1 AND expires_at > NOW()', [
            sessionToken
        ]);
        if (!result.rows[0]) return null;
        const row = result.rows[0];
        return {
            id: row.id,
            userId: row.user_id,
            token: row.session_token,
            expiresAt: new Date(row.expires_at),
            isActive: true,
            userAgent: row.user_agent,
            ipAddress: row.ip_address,
            lastActivityAt: new Date(row.last_activity_at || row.created_at),
            createdAt: new Date(row.created_at),
            updatedAt: new Date(row.updated_at || row.created_at)
        };
    }
    async deleteSession(sessionToken) {
        const result = await this.query('DELETE FROM user_sessions WHERE session_token = $1', [
            sessionToken
        ]);
        return result.rowCount > 0;
    }
    async deleteExpiredSessions() {
        const result = await this.query('DELETE FROM user_sessions WHERE expires_at <= NOW()');
        return result.rowCount;
    }
    // === МЕТОДЫ ДЛЯ КОММЕНТАРИЕВ ===
    async createComment(content, taskId, authorId) {
        const result = await this.query(`INSERT INTO comments (content, task_id, author_id) 
       VALUES ($1, $2, $3) 
       RETURNING *`, [
            content,
            taskId,
            authorId
        ]);
        return result.rows[0];
    }
    async getCommentsByTaskId(taskId) {
        const result = await this.query('SELECT * FROM comments WHERE task_id = $1 AND deleted_at IS NULL ORDER BY created_at', [
            taskId
        ]);
        return result.rows;
    }
    async updateComment(id, content) {
        const result = await this.query('UPDATE comments SET content = $2 WHERE id = $1 RETURNING *', [
            id,
            content
        ]);
        return result.rows[0] || null;
    }
    async deleteComment(id) {
        const result = await this.query('UPDATE comments SET deleted_at = CURRENT_TIMESTAMP WHERE id = $1', [
            id
        ]);
        return result.rowCount > 0;
    }
    // === МЕТОДЫ ДЛЯ ТЕГОВ ===
    async createTag(name, color, projectId) {
        const result = await this.query(`INSERT INTO tags (name, color, project_id) 
       VALUES ($1, $2, $3) 
       RETURNING *`, [
            name,
            color,
            projectId
        ]);
        return result.rows[0];
    }
    async getTagsByProjectId(projectId) {
        const result = await this.query('SELECT * FROM tags WHERE project_id = $1 ORDER BY name', [
            projectId
        ]);
        return result.rows;
    }
    async addTagToTask(taskId, tagId) {
        try {
            await this.query('INSERT INTO task_tags (task_id, tag_id) VALUES ($1, $2)', [
                taskId,
                tagId
            ]);
            return true;
        } catch (error) {
            return false;
        }
    }
    async removeTagFromTask(taskId, tagId) {
        const result = await this.query('DELETE FROM task_tags WHERE task_id = $1 AND tag_id = $2', [
            taskId,
            tagId
        ]);
        return result.rowCount > 0;
    }
    async getTagsByTaskId(taskId) {
        const result = await this.query(`SELECT t.* FROM tags t 
       JOIN task_tags tt ON t.id = tt.tag_id 
       WHERE tt.task_id = $1`, [
            taskId
        ]);
        return result.rows;
    }
    // Статический метод для получения экземпляра (Singleton)
    static getInstance() {
        if (!PostgreSQLAdapter.instance) {
            const config = {
                host: process.env.DB_HOST || 'localhost',
                port: parseInt(process.env.DB_PORT || '5432'),
                database: process.env.DB_NAME || 'encore_tasks',
                user: process.env.DB_USER || 'postgres',
                password: process.env.DB_PASSWORD || 'password',
                ssl: process.env.DB_SSL === 'true'
            };
            PostgreSQLAdapter.instance = new PostgreSQLAdapter(config);
        }
        return PostgreSQLAdapter.instance;
    }
}
// Экспорт экземпляра адаптера
let dbAdapter = null;
function getPostgreSQLAdapter() {
    if (!dbAdapter) {
        const config = {
            host: process.env.DB_HOST || 'localhost',
            port: parseInt(process.env.DB_PORT || '5432'),
            database: process.env.DB_NAME || 'encore_tasks',
            user: process.env.DB_USER || 'postgres',
            password: process.env.DB_PASSWORD || 'password',
            ssl: process.env.DB_SSL === 'true'
        };
        dbAdapter = new PostgreSQLAdapter(config);
    }
    return dbAdapter;
}
const __TURBOPACK__default__export__ = getPostgreSQLAdapter;
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
"[project]/src/lib/database-adapter-optimized.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname, a: __turbopack_async_module__ } = __turbopack_context__;
__turbopack_async_module__(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {
__turbopack_context__.s({
    "DatabaseAdapterOptimized": (()=>DatabaseAdapterOptimized),
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$postgresql$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/postgresql-adapter.ts [app-route] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$postgresql$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__
]);
([__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$postgresql$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__);
;
/**
 * Оптимизированный адаптер базы данных
 * Исправляет проблемы:
 * - Устраняет повторную инициализацию при каждом запросе
 * - Использует Singleton паттерн для управления соединениями
 * - Добавляет правильную обработку ошибок
 * - Оптимизирует производительность
 */ class DatabaseAdapterOptimized {
    static instance;
    postgresqlAdapter;
    isInitialized = false;
    initializationPromise = null;
    constructor(){
        this.postgresqlAdapter = __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$postgresql$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PostgreSQLAdapter"].getInstance();
    }
    static getInstance() {
        if (!DatabaseAdapterOptimized.instance) {
            DatabaseAdapterOptimized.instance = new DatabaseAdapterOptimized();
        }
        return DatabaseAdapterOptimized.instance;
    }
    /**
   * Инициализация адаптера (вызывается только один раз)
   */ async initialize() {
        if (this.isInitialized) {
            return;
        }
        if (this.initializationPromise) {
            return this.initializationPromise;
        }
        this.initializationPromise = this.performInitialization();
        return this.initializationPromise;
    }
    async performInitialization() {
        try {
            await this.postgresqlAdapter.initialize();
            this.isInitialized = true;
            console.log('✅ Database Adapter оптимизирован и готов к работе');
        } catch (error) {
            console.error('❌ Ошибка инициализации Database Adapter:', error);
            this.initializationPromise = null;
            throw error;
        }
    }
    /**
   * Проверка инициализации перед выполнением операций
   */ async ensureInitialized() {
        if (!this.isInitialized) {
            await this.initialize();
        }
    }
    // === МЕТОДЫ ДЛЯ ПОЛЬЗОВАТЕЛЕЙ ===
    async createUser(email, password, name, role = 'user') {
        await this.ensureInitialized();
        return this.postgresqlAdapter.createUser(email, password, name, role);
    }
    async getUserById(id) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getUserById(id.toString());
    }
    async getUserByEmail(email) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getUserByEmail(email);
    }
    async getAllUsers() {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getAllUsers();
    }
    async getUsers() {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getAllUsers();
    }
    async updateUser(id, updates) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.updateUser(id.toString(), updates);
    }
    async deleteUser(id) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.deleteUser(id.toString());
    }
    // === МЕТОДЫ ДЛЯ СЕССИЙ ===
    async createSession(sessionData) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.createSession(sessionData.token, sessionData.userId, sessionData.expiresAt);
    }
    async getSessionByToken(token) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getSessionByToken(token);
    }
    async deleteSession(token) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.deleteSession(token);
    }
    // === МЕТОДЫ ДЛЯ ПРОЕКТОВ ===
    async createProject(projectData) {
        await this.ensureInitialized();
        const { name, description, createdBy, color } = projectData;
        return this.postgresqlAdapter.createProject(name, description || '', createdBy, color);
    }
    async getProjectById(id) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getProjectById(id.toString());
    }
    async getAllProjects() {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getAllProjects();
    }
    async getUserProjects(userId) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getUserProjects(userId.toString());
    }
    async getProjectsByUserId(userId) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getUserProjects(userId.toString());
    }
    async getProjectsByCreatorId(creatorId) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getProjectsByCreatorId(creatorId.toString());
    }
    async hasProjectAccess(userId, projectId) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.hasProjectAccess(userId.toString(), projectId.toString());
    }
    async updateProject(id, updateData) {
        await this.ensureInitialized();
        const result = await this.postgresqlAdapter.updateProject(id.toString(), updateData);
        return result;
    }
    async deleteProject(id) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.deleteProject(id.toString());
    }
    // === МЕТОДЫ ДЛЯ ДОСОК ===
    async createBoard(name, description, projectId) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.createBoard(name, description, projectId);
    }
    async getBoardById(id) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getBoardById(id.toString());
    }
    async getProjectBoards(projectId) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getProjectBoards(projectId.toString());
    }
    async deleteBoard(id) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.deleteBoard(id.toString());
    }
    // === МЕТОДЫ ДЛЯ КОЛОНОК ===
    async createColumn(name, boardId, position, color) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.createColumn(name, boardId, position, color);
    }
    async getColumnById(id) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getColumnById(id.toString());
    }
    async getBoardColumns(boardId) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getBoardColumns(boardId.toString());
    }
    async deleteColumn(id) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.deleteColumn(id.toString());
    }
    // === МЕТОДЫ ДЛЯ ЗАДАЧ ===
    async createTask(taskData) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.createTask(taskData);
    }
    async getTaskById(id) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getTaskById(id.toString());
    }
    async getTasks(filters = {}) {
        await this.ensureInitialized();
        const postgresFilters = {
            projectId: filters.projectId ? filters.projectId.toString() : undefined,
            boardId: filters.boardId ? filters.boardId.toString() : undefined,
            assigneeId: filters.assigneeId ? filters.assigneeId.toString() : undefined,
            columnId: filters.columnId ? filters.columnId.toString() : undefined
        };
        return this.postgresqlAdapter.getTasks(postgresFilters);
    }
    async updateTask(id, updates) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.updateTask(id.toString(), updates);
    }
    async deleteTask(id) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.deleteTask(id.toString());
    }
    // === СЛУЖЕБНЫЕ МЕТОДЫ ===
    /**
   * Проверка состояния адаптера
   */ isReady() {
        return this.isInitialized;
    }
    /**
   * Получение статистики использования
   */ async getStats() {
        return {
            isInitialized: this.isInitialized,
            adapterType: 'PostgreSQL Optimized',
            connectionStatus: this.isInitialized ? 'Connected' : 'Disconnected'
        };
    }
    /**
   * Очистка ресурсов
   */ async cleanup() {
        if (this.isInitialized) {
            await this.postgresqlAdapter.close();
            this.isInitialized = false;
            this.initializationPromise = null;
            console.log('✅ Database Adapter очищен');
        }
    }
    /**
   * Полная переинициализация адаптера
   */ async reinitialize() {
        await this.cleanup();
        await this.initialize();
    }
    /**
   * Выполнение сырого SQL запроса (для совместимости с PostgreSQL API)
   */ async executeRawQuery(sql, params) {
        await this.initialize();
        return await this.postgresqlAdapter.query(sql, params);
    }
    /**
   * Выполнение SQL запроса (для совместимости с репозиториями)
   */ async query(sql, params) {
        await this.initialize();
        return await this.postgresqlAdapter.query(sql, params);
    }
}
// Экспортируем singleton instance
const databaseAdapter = DatabaseAdapterOptimized.getInstance();
const __TURBOPACK__default__export__ = databaseAdapter;
;
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
"[project]/src/lib/auth.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname, a: __turbopack_async_module__ } = __turbopack_context__;
__turbopack_async_module__(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {
__turbopack_context__.s({
    "requireAdmin": (()=>requireAdmin),
    "verifyAuth": (()=>verifyAuth),
    "verifyProjectAccess": (()=>verifyProjectAccess)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jsonwebtoken/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2d$optimized$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/database-adapter-optimized.ts [app-route] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2d$optimized$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__
]);
([__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2d$optimized$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__);
;
;
async function verifyAuth(request) {
    try {
        // Получение токена из cookie или заголовка Authorization
        const token = request.cookies.get('auth-token')?.value || request.headers.get('authorization')?.replace('Bearer ', '');
        console.log('Auth token found:', !!token);
        if (!token) {
            console.log('No auth token found in cookies or headers');
            return {
                success: false,
                error: 'Токен аутентификации не найден'
            };
        }
        // Проверка JWT токена
        let decoded;
        try {
            decoded = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].verify(token, process.env.JWT_SECRET || 'your-secret-key');
            console.log('JWT verified successfully for user:', decoded.userId);
        } catch (jwtError) {
            console.log('JWT verification failed:', jwtError);
            return {
                success: false,
                error: 'Невалидный токен'
            };
        }
        // Используем оптимизированный адаптер для работы с сессиями
        await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2d$optimized$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].initialize();
        try {
            // Ищем сессию через адаптер
            const session = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2d$optimized$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].getSessionByToken(token);
            console.log('Session found:', !!session);
            if (!session) {
                console.log('Session not found or expired for token');
                return {
                    success: false,
                    error: 'Сессия не найдена или истекла'
                };
            }
            // Получаем пользователя через адаптер
            const user = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2d$optimized$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].getUserById(session.userId);
            if (!user) {
                return {
                    success: false,
                    error: 'Пользователь не найден'
                };
            }
            // Проверяем статус одобрения пользователя
            // Используем approval_status для PostgreSQL
            const isApproved = user.isApproved !== undefined ? user.isApproved : true;
            if (!isApproved && user.role !== 'admin') {
                return {
                    success: false,
                    error: 'Пользователь не одобрен'
                };
            }
            return {
                success: true,
                user: {
                    userId: String(user.id),
                    email: user.email,
                    role: user.role,
                    name: user.name
                }
            };
        } catch (error) {
            console.error('Auth error:', error);
            return {
                success: false,
                error: 'Ошибка аутентификации'
            };
        }
    } catch (error) {
        console.error('Ошибка проверки аутентификации:', error);
        return {
            success: false,
            error: 'Внутренняя ошибка сервера'
        };
    }
}
async function verifyProjectAccess(userId, projectId, requiredRole) {
    try {
        await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2d$optimized$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].initialize();
        // Получаем проекты через адаптер
        const projects = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2d$optimized$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].getAllProjects();
        const project = projects.find((p)=>p.id === projectId);
        if (!project) {
            return {
                hasAccess: false
            };
        }
        // Проверяем, является ли пользователь владельцем
        if (project.createdBy === userId) {
            return {
                hasAccess: true,
                userRole: 'owner'
            };
        }
        // Получаем участников проекта через getUserProjects
        const userProjects = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2d$optimized$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].getUserProjects(userId);
        const hasAccess = userProjects.some((p)=>p.id === projectId);
        if (!hasAccess) {
            return {
                hasAccess: false
            };
        }
        // Для упрощения, считаем что у пользователя есть доступ как участник
        const userRole = 'member';
        // Проверка требуемой роли
        if (requiredRole) {
            const roleHierarchy = {
                owner: 3,
                admin: 2,
                member: 1
            };
            const userRoleLevel = roleHierarchy[userRole] || 0;
            const requiredRoleLevel = roleHierarchy[requiredRole];
            if (userRoleLevel < requiredRoleLevel) {
                return {
                    hasAccess: false,
                    userRole
                };
            }
        }
        return {
            hasAccess: true,
            userRole
        };
    } catch (error) {
        console.error('Ошибка проверки доступа к проекту:', error);
        return {
            hasAccess: false
        };
    }
}
async function requireAdmin(request) {
    const authResult = await verifyAuth(request);
    if (!authResult.success) {
        return {
            success: false,
            error: authResult.error
        };
    }
    if (authResult.user.role !== 'admin') {
        return {
            success: false,
            error: 'Требуются права администратора'
        };
    }
    return {
        success: true,
        user: authResult.user
    };
}
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
"[project]/src/app/api/auth/me/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname, a: __turbopack_async_module__ } = __turbopack_context__;
__turbopack_async_module__(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {
__turbopack_context__.s({
    "GET": (()=>GET)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/auth.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2d$optimized$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/database-adapter-optimized.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__,
    __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2d$optimized$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__
]);
([__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2d$optimized$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__);
;
;
;
;
async function GET(request) {
    try {
        const authResult = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["verifyAuth"])(request);
        if (!authResult.success) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: authResult.error
            }, {
                status: 401
            });
        }
        const { userId } = authResult.user;
        const user = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2d$optimized$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].getUserById(userId);
        if (!user) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Пользователь не найден'
            }, {
                status: 404
            });
        }
        // Преобразование в формат API с правильной типизацией
        const userResult = {
            id: user.userId,
            name: user.name,
            email: user.email,
            role: user.role,
            status: user.is_active ? 'active' : 'inactive',
            avatar: user.avatar || null,
            createdAt: user.created_at,
            updatedAt: user.updated_at,
            lastLoginAt: user.last_login_at
        };
        // Generate ETag based on user data
        const etag = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["createHash"])('md5').update(JSON.stringify(userResult)).digest('hex');
        // Check if client has cached version
        const clientETag = request.headers.get('if-none-match');
        if (clientETag === etag) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"](null, {
                status: 304
            });
        }
        const response = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            user: userResult
        });
        // Set caching headers
        response.headers.set('ETag', etag);
        response.headers.set('Cache-Control', 'private, max-age=300, must-revalidate'); // 5 minutes
        response.headers.set('Vary', 'Authorization, Cookie');
        return response;
    } catch (error) {
        console.error('Ошибка получения текущего пользователя:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Внутренняя ошибка сервера'
        }, {
            status: 500
        });
    }
}
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__ac46a076._.js.map