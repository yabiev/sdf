module.exports = {

"[project]/.next-internal/server/app/api/boards/route/actions.js [app-rsc] (server actions loader, ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/pg [external] (pg, esm_import)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname, a: __turbopack_async_module__ } = __turbopack_context__;
__turbopack_async_module__(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {
const mod = await __turbopack_context__.y("pg");

__turbopack_context__.n(mod);
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, true);}),
"[project]/src/lib/postgresql-adapter.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname, a: __turbopack_async_module__ } = __turbopack_context__;
__turbopack_async_module__(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {
__turbopack_context__.s({
    "PostgreSQLAdapter": (()=>PostgreSQLAdapter),
    "default": (()=>__TURBOPACK__default__export__),
    "getPostgreSQLAdapter": (()=>getPostgreSQLAdapter)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$29$__ = __turbopack_context__.i("[externals]/pg [external] (pg, esm_import)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bcryptjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bcryptjs/index.js [app-route] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$29$__
]);
([__TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__);
;
;
class PostgreSQLAdapter {
    static instance = null;
    pool;
    isInitialized = false;
    constructor(config){
        this.pool = new __TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$29$__["Pool"]({
            host: config.host,
            port: config.port,
            database: config.database,
            user: config.user,
            password: config.password,
            ssl: config.ssl ? {
                rejectUnauthorized: false
            } : false,
            max: 20,
            idleTimeoutMillis: 30000,
            connectionTimeoutMillis: 2000
        });
    }
    // Инициализация базы данных
    async initialize() {
        if (this.isInitialized) return;
        try {
            const client = await this.pool.connect();
            // Проверяем подключение
            await client.query('SELECT NOW()');
            console.log('✅ PostgreSQL подключение установлено');
            client.release();
            this.isInitialized = true;
        } catch (error) {
            console.error('❌ Ошибка подключения к PostgreSQL:', error);
            throw error;
        }
    }
    // Закрытие пула соединений
    async close() {
        await this.pool.end();
        this.isInitialized = false;
    }
    // Получение клиента для транзакций
    async getClient() {
        return await this.pool.connect();
    }
    // Выполнение запроса
    async query(text, params) {
        const client = await this.pool.connect();
        try {
            console.log('SQL Query:', text);
            console.log('SQL Params:', params);
            const result = await client.query(text, params);
            return result;
        } finally{
            client.release();
        }
    }
    // === МЕТОДЫ ДЛЯ ПОЛЬЗОВАТЕЛЕЙ ===
    async createUser(email, password, name, role = 'user') {
        const hashedPassword = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bcryptjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].hash(password, 12);
        const result = await this.query(`INSERT INTO users (email, password_hash, name, role, approval_status) 
       VALUES ($1, $2, $3, $4, $5) 
       RETURNING *`, [
            email,
            hashedPassword,
            name,
            role,
            'pending'
        ]);
        return result.rows[0];
    }
    async getUserByEmail(email) {
        const result = await this.query('SELECT * FROM users WHERE email = $1 AND deleted_at IS NULL', [
            email
        ]);
        return result.rows[0] || null;
    }
    async getUserById(id) {
        const result = await this.query('SELECT * FROM users WHERE id = $1 AND deleted_at IS NULL', [
            id
        ]);
        const row = result.rows[0];
        if (!row) return null;
        // Маппинг полей базы данных в User интерфейс
        return {
            id: row.id,
            userId: row.id,
            name: row.name,
            email: row.email,
            role: row.role,
            status: row.is_active ? 'active' : 'inactive',
            approval_status: row.approval_status,
            avatar: row.avatar,
            createdAt: row.created_at,
            updatedAt: row.updated_at,
            lastLoginAt: row.last_login_at,
            is_active: row.is_active,
            created_at: row.created_at,
            updated_at: row.updated_at,
            last_login_at: row.last_login_at
        };
    }
    async updateUser(id, updates) {
        const fields = Object.keys(updates).filter((key)=>key !== 'id');
        const values = fields.map((field)=>updates[field]);
        const setClause = fields.map((field, index)=>`${field} = $${index + 2}`).join(', ');
        if (fields.length === 0) {
            return await this.getUserById(id);
        }
        const result = await this.query(`UPDATE users SET ${setClause} WHERE id = $1 RETURNING *`, [
            id,
            ...values
        ]);
        return result.rows[0] || null;
    }
    async getAllUsers() {
        const result = await this.query('SELECT * FROM users WHERE deleted_at IS NULL ORDER BY created_at DESC');
        return result.rows;
    }
    async deleteUser(id) {
        const result = await this.query('UPDATE users SET deleted_at = CURRENT_TIMESTAMP WHERE id = $1', [
            id
        ]);
        return result.rowCount > 0;
    }
    // === МЕТОДЫ ДЛЯ ПРОЕКТОВ ===
    async createProject(name, description, ownerId, color) {
        const result = await this.query(`INSERT INTO projects (name, description, creator_id, color)
     VALUES ($1, $2, $3, $4) RETURNING *`, [
            name,
            description,
            ownerId,
            color || '#3B82F6'
        ]);
        return result.rows[0];
    }
    async getProjectById(id) {
        const result = await this.query('SELECT * FROM projects WHERE id = $1 AND deleted_at IS NULL', [
            id
        ]);
        return result.rows[0] || null;
    }
    async getProjectsByUserId(userId) {
        const result = await this.query(`SELECT DISTINCT p.* FROM projects p 
       LEFT JOIN project_members pm ON p.id = pm.project_id 
       WHERE (p.creator_id = $1 OR pm.user_id = $1) AND p.deleted_at IS NULL 
       ORDER BY p.created_at DESC`, [
            userId
        ]);
        return result.rows;
    }
    async getAllProjects() {
        const result = await this.query('SELECT * FROM projects WHERE deleted_at IS NULL ORDER BY created_at DESC');
        return result.rows;
    }
    async updateProject(id, updates) {
        const fields = Object.keys(updates).filter((key)=>key !== 'id');
        const values = fields.map((field)=>updates[field]);
        const setClause = fields.map((field, index)=>`${field} = $${index + 2}`).join(', ');
        if (fields.length === 0) {
            return await this.getProjectById(id);
        }
        const result = await this.query(`UPDATE projects SET ${setClause} WHERE id = $1 RETURNING *`, [
            id,
            ...values
        ]);
        return result.rows[0] || null;
    }
    async deleteProject(id) {
        const result = await this.query('UPDATE projects SET deleted_at = CURRENT_TIMESTAMP WHERE id = $1', [
            id
        ]);
        return result.rowCount > 0;
    }
    async hasProjectAccess(userId, projectId) {
        try {
            // Проверяем, является ли пользователь владельцем проекта
            const ownerResult = await this.query('SELECT creator_id FROM projects WHERE id = $1 AND deleted_at IS NULL', [
                projectId
            ]);
            if (ownerResult.rows.length === 0) {
                return false; // Проект не найден
            }
            const projectOwner = ownerResult.rows[0].creator_id;
            if (projectOwner === userId) {
                return true; // Пользователь является владельцем
            }
            // Проверяем членство в проекте
            const memberResult = await this.query('SELECT 1 FROM project_members WHERE project_id = $1 AND user_id = $2', [
                projectId,
                userId
            ]);
            return memberResult.rows.length > 0;
        } catch (error) {
            console.error('Error checking project access:', error);
            return false;
        }
    }
    // === МЕТОДЫ ДЛЯ ДОСОК ===
    async createBoard(name, description, projectId) {
        const result = await this.query(`INSERT INTO boards (name, project_id) 
       VALUES ($1, $2) 
       RETURNING *`, [
            name,
            projectId
        ]);
        return result.rows[0];
    }
    async getBoardById(id) {
        const result = await this.query('SELECT * FROM boards WHERE id = $1 AND deleted_at IS NULL', [
            id
        ]);
        return result.rows[0] || null;
    }
    async getBoardsByProjectId(projectId) {
        const result = await this.query('SELECT * FROM boards WHERE project_id = $1 AND deleted_at IS NULL ORDER BY position, created_at', [
            projectId
        ]);
        return result.rows;
    }
    async updateBoard(id, updates) {
        const fields = Object.keys(updates).filter((key)=>key !== 'id');
        const values = fields.map((field)=>updates[field]);
        const setClause = fields.map((field, index)=>`${field} = $${index + 2}`).join(', ');
        if (fields.length === 0) {
            return await this.getBoardById(id);
        }
        const result = await this.query(`UPDATE boards SET ${setClause} WHERE id = $1 RETURNING *`, [
            id,
            ...values
        ]);
        return result.rows[0] || null;
    }
    async deleteBoard(id) {
        const result = await this.query('UPDATE boards SET deleted_at = CURRENT_TIMESTAMP WHERE id = $1', [
            id
        ]);
        return result.rowCount > 0;
    }
    // === МЕТОДЫ ДЛЯ КОЛОНОК ===
    async createColumn(name, boardId, position, color) {
        const result = await this.query(`INSERT INTO columns (title, board_id, position, color) 
       VALUES ($1, $2, $3, $4) 
       RETURNING *`, [
            name,
            boardId,
            position || 0,
            color || '#6B7280'
        ]);
        return result.rows[0];
    }
    async getColumnById(id) {
        const result = await this.query('SELECT * FROM columns WHERE id = $1 AND deleted_at IS NULL', [
            id
        ]);
        return result.rows[0] || null;
    }
    async getColumnsByBoardId(boardId) {
        const result = await this.query('SELECT * FROM columns WHERE board_id = $1 AND deleted_at IS NULL ORDER BY position, created_at', [
            boardId
        ]);
        return result.rows;
    }
    async updateColumn(id, updates) {
        const fields = Object.keys(updates).filter((key)=>key !== 'id');
        const values = fields.map((field)=>updates[field]);
        const setClause = fields.map((field, index)=>`${field} = $${index + 2}`).join(', ');
        if (fields.length === 0) {
            return await this.getColumnById(id);
        }
        const result = await this.query(`UPDATE columns SET ${setClause} WHERE id = $1 RETURNING *`, [
            id,
            ...values
        ]);
        return result.rows[0] || null;
    }
    async deleteColumn(id) {
        const result = await this.query('UPDATE columns SET deleted_at = CURRENT_TIMESTAMP WHERE id = $1', [
            id
        ]);
        return result.rowCount > 0;
    }
    // === МЕТОДЫ ДЛЯ ЗАДАЧ ===
    async createTask(taskData) {
        const { title, description, status = 'todo', priority = 'medium', project_id, board_id, column_id, assignee_id, reporter_id, position = 0 } = taskData;
        const result = await this.query(`INSERT INTO tasks (title, description, status, priority, project_id, board_id, column_id, assignee_id, reporter_id, position) 
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) 
       RETURNING *`, [
            title,
            description,
            status,
            priority,
            project_id,
            board_id,
            column_id,
            assignee_id,
            reporter_id,
            position
        ]);
        return result.rows[0];
    }
    async getTaskById(id) {
        const result = await this.query('SELECT * FROM tasks WHERE id = $1 AND deleted_at IS NULL', [
            id
        ]);
        return result.rows[0] || null;
    }
    async getTasksByProjectId(projectId) {
        const result = await this.query('SELECT * FROM tasks WHERE project_id = $1 AND deleted_at IS NULL ORDER BY position, created_at', [
            projectId
        ]);
        return result.rows;
    }
    async getTasksByColumnId(columnId) {
        const result = await this.query('SELECT * FROM tasks WHERE column_id = $1 AND deleted_at IS NULL ORDER BY position, created_at', [
            columnId
        ]);
        return result.rows;
    }
    async updateTask(id, updates) {
        const fields = Object.keys(updates).filter((key)=>key !== 'id');
        const values = fields.map((field)=>updates[field]);
        const setClause = fields.map((field, index)=>`${field} = $${index + 2}`).join(', ');
        if (fields.length === 0) {
            return await this.getTaskById(id);
        }
        const result = await this.query(`UPDATE tasks SET ${setClause} WHERE id = $1 RETURNING *`, [
            id,
            ...values
        ]);
        return result.rows[0] || null;
    }
    async deleteTask(id) {
        const result = await this.query('UPDATE tasks SET deleted_at = CURRENT_TIMESTAMP WHERE id = $1', [
            id
        ]);
        return result.rowCount > 0;
    }
    // === МЕТОДЫ ДЛЯ СЕССИЙ ===
    async createSession(sessionToken, userId, expiresAt) {
        const result = await this.query(`INSERT INTO user_sessions (session_token, user_id, expires_at)
     VALUES ($1, $2, $3)
     RETURNING *`, [
            sessionToken,
            userId,
            expiresAt
        ]);
        const row = result.rows[0];
        return {
            id: row.id,
            userId: row.user_id,
            token: row.session_token,
            expiresAt: new Date(row.expires_at),
            isActive: true,
            userAgent: row.user_agent,
            ipAddress: row.ip_address,
            lastActivityAt: new Date(row.last_activity_at || row.created_at),
            createdAt: new Date(row.created_at),
            updatedAt: new Date(row.updated_at || row.created_at)
        };
    }
    async getSessionByToken(sessionToken) {
        const result = await this.query('SELECT * FROM user_sessions WHERE session_token = $1 AND expires_at > NOW()', [
            sessionToken
        ]);
        if (!result.rows[0]) return null;
        const row = result.rows[0];
        return {
            id: row.id,
            userId: row.user_id,
            token: row.session_token,
            expiresAt: new Date(row.expires_at),
            isActive: true,
            userAgent: row.user_agent,
            ipAddress: row.ip_address,
            lastActivityAt: new Date(row.last_activity_at || row.created_at),
            createdAt: new Date(row.created_at),
            updatedAt: new Date(row.updated_at || row.created_at)
        };
    }
    async deleteSession(sessionToken) {
        const result = await this.query('DELETE FROM user_sessions WHERE session_token = $1', [
            sessionToken
        ]);
        return result.rowCount > 0;
    }
    async deleteExpiredSessions() {
        const result = await this.query('DELETE FROM user_sessions WHERE expires_at <= NOW()');
        return result.rowCount;
    }
    // === МЕТОДЫ ДЛЯ КОММЕНТАРИЕВ ===
    async createComment(content, taskId, authorId) {
        const result = await this.query(`INSERT INTO comments (content, task_id, author_id) 
       VALUES ($1, $2, $3) 
       RETURNING *`, [
            content,
            taskId,
            authorId
        ]);
        return result.rows[0];
    }
    async getCommentsByTaskId(taskId) {
        const result = await this.query('SELECT * FROM comments WHERE task_id = $1 AND deleted_at IS NULL ORDER BY created_at', [
            taskId
        ]);
        return result.rows;
    }
    async updateComment(id, content) {
        const result = await this.query('UPDATE comments SET content = $2 WHERE id = $1 RETURNING *', [
            id,
            content
        ]);
        return result.rows[0] || null;
    }
    async deleteComment(id) {
        const result = await this.query('UPDATE comments SET deleted_at = CURRENT_TIMESTAMP WHERE id = $1', [
            id
        ]);
        return result.rowCount > 0;
    }
    // === МЕТОДЫ ДЛЯ ТЕГОВ ===
    async createTag(name, color, projectId) {
        const result = await this.query(`INSERT INTO tags (name, color, project_id) 
       VALUES ($1, $2, $3) 
       RETURNING *`, [
            name,
            color,
            projectId
        ]);
        return result.rows[0];
    }
    async getTagsByProjectId(projectId) {
        const result = await this.query('SELECT * FROM tags WHERE project_id = $1 ORDER BY name', [
            projectId
        ]);
        return result.rows;
    }
    async addTagToTask(taskId, tagId) {
        try {
            await this.query('INSERT INTO task_tags (task_id, tag_id) VALUES ($1, $2)', [
                taskId,
                tagId
            ]);
            return true;
        } catch (error) {
            return false;
        }
    }
    async removeTagFromTask(taskId, tagId) {
        const result = await this.query('DELETE FROM task_tags WHERE task_id = $1 AND tag_id = $2', [
            taskId,
            tagId
        ]);
        return result.rowCount > 0;
    }
    async getTagsByTaskId(taskId) {
        const result = await this.query(`SELECT t.* FROM tags t 
       JOIN task_tags tt ON t.id = tt.tag_id 
       WHERE tt.task_id = $1`, [
            taskId
        ]);
        return result.rows;
    }
    // Статический метод для получения экземпляра (Singleton)
    static getInstance() {
        if (!PostgreSQLAdapter.instance) {
            const config = {
                host: process.env.DB_HOST || 'localhost',
                port: parseInt(process.env.DB_PORT || '5432'),
                database: process.env.DB_NAME || 'encore_tasks',
                user: process.env.DB_USER || 'postgres',
                password: process.env.DB_PASSWORD || 'password',
                ssl: process.env.DB_SSL === 'true'
            };
            PostgreSQLAdapter.instance = new PostgreSQLAdapter(config);
        }
        return PostgreSQLAdapter.instance;
    }
}
// Экспорт экземпляра адаптера
let dbAdapter = null;
function getPostgreSQLAdapter() {
    if (!dbAdapter) {
        const config = {
            host: process.env.DB_HOST || 'localhost',
            port: parseInt(process.env.DB_PORT || '5432'),
            database: process.env.DB_NAME || 'encore_tasks',
            user: process.env.DB_USER || 'postgres',
            password: process.env.DB_PASSWORD || 'password',
            ssl: process.env.DB_SSL === 'true'
        };
        dbAdapter = new PostgreSQLAdapter(config);
    }
    return dbAdapter;
}
const __TURBOPACK__default__export__ = getPostgreSQLAdapter;
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
"[project]/src/lib/database-adapter-optimized.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname, a: __turbopack_async_module__ } = __turbopack_context__;
__turbopack_async_module__(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {
__turbopack_context__.s({
    "DatabaseAdapterOptimized": (()=>DatabaseAdapterOptimized),
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$postgresql$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/postgresql-adapter.ts [app-route] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$postgresql$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__
]);
([__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$postgresql$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__);
;
/**
 * Оптимизированный адаптер базы данных
 * Исправляет проблемы:
 * - Устраняет повторную инициализацию при каждом запросе
 * - Использует Singleton паттерн для управления соединениями
 * - Добавляет правильную обработку ошибок
 * - Оптимизирует производительность
 */ class DatabaseAdapterOptimized {
    static instance;
    postgresqlAdapter;
    isInitialized = false;
    initializationPromise = null;
    constructor(){
        this.postgresqlAdapter = __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$postgresql$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PostgreSQLAdapter"].getInstance();
    }
    static getInstance() {
        if (!DatabaseAdapterOptimized.instance) {
            DatabaseAdapterOptimized.instance = new DatabaseAdapterOptimized();
        }
        return DatabaseAdapterOptimized.instance;
    }
    /**
   * Инициализация адаптера (вызывается только один раз)
   */ async initialize() {
        if (this.isInitialized) {
            return;
        }
        if (this.initializationPromise) {
            return this.initializationPromise;
        }
        this.initializationPromise = this.performInitialization();
        return this.initializationPromise;
    }
    async performInitialization() {
        try {
            await this.postgresqlAdapter.initialize();
            this.isInitialized = true;
            console.log('✅ Database Adapter оптимизирован и готов к работе');
        } catch (error) {
            console.error('❌ Ошибка инициализации Database Adapter:', error);
            this.initializationPromise = null;
            throw error;
        }
    }
    /**
   * Проверка инициализации перед выполнением операций
   */ async ensureInitialized() {
        if (!this.isInitialized) {
            await this.initialize();
        }
    }
    // === МЕТОДЫ ДЛЯ ПОЛЬЗОВАТЕЛЕЙ ===
    async createUser(email, password, name, role = 'user') {
        await this.ensureInitialized();
        return this.postgresqlAdapter.createUser(email, password, name, role);
    }
    async getUserById(id) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getUserById(id.toString());
    }
    async getUserByEmail(email) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getUserByEmail(email);
    }
    async getAllUsers() {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getAllUsers();
    }
    async getUsers() {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getAllUsers();
    }
    async updateUser(id, updates) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.updateUser(id.toString(), updates);
    }
    async deleteUser(id) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.deleteUser(id.toString());
    }
    // === МЕТОДЫ ДЛЯ СЕССИЙ ===
    async createSession(sessionData) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.createSession(sessionData.token, sessionData.userId, sessionData.expiresAt);
    }
    async getSessionByToken(token) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getSessionByToken(token);
    }
    async deleteSession(token) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.deleteSession(token);
    }
    // === МЕТОДЫ ДЛЯ ПРОЕКТОВ ===
    async createProject(projectData) {
        await this.ensureInitialized();
        const { name, description, createdBy, color } = projectData;
        return this.postgresqlAdapter.createProject(name, description || '', createdBy, color);
    }
    async getProjectById(id) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getProjectById(id.toString());
    }
    async getAllProjects() {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getAllProjects();
    }
    async getUserProjects(userId) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getUserProjects(userId.toString());
    }
    async getProjectsByUserId(userId) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getUserProjects(userId.toString());
    }
    async getProjectsByCreatorId(creatorId) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getProjectsByCreatorId(creatorId.toString());
    }
    async hasProjectAccess(userId, projectId) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.hasProjectAccess(userId.toString(), projectId.toString());
    }
    async updateProject(id, updateData) {
        await this.ensureInitialized();
        const result = await this.postgresqlAdapter.updateProject(id.toString(), updateData);
        return result;
    }
    async deleteProject(id) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.deleteProject(id.toString());
    }
    // === МЕТОДЫ ДЛЯ ДОСОК ===
    async createBoard(name, description, projectId) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.createBoard(name, description, projectId);
    }
    async getBoardById(id) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getBoardById(id.toString());
    }
    async getProjectBoards(projectId) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getProjectBoards(projectId.toString());
    }
    async deleteBoard(id) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.deleteBoard(id.toString());
    }
    // === МЕТОДЫ ДЛЯ КОЛОНОК ===
    async createColumn(name, boardId, position, color) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.createColumn(name, boardId, position, color);
    }
    async getColumnById(id) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getColumnById(id.toString());
    }
    async getBoardColumns(boardId) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getBoardColumns(boardId.toString());
    }
    async deleteColumn(id) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.deleteColumn(id.toString());
    }
    // === МЕТОДЫ ДЛЯ ЗАДАЧ ===
    async createTask(taskData) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.createTask(taskData);
    }
    async getTaskById(id) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.getTaskById(id.toString());
    }
    async getTasks(filters = {}) {
        await this.ensureInitialized();
        const postgresFilters = {
            projectId: filters.projectId ? filters.projectId.toString() : undefined,
            boardId: filters.boardId ? filters.boardId.toString() : undefined,
            assigneeId: filters.assigneeId ? filters.assigneeId.toString() : undefined,
            columnId: filters.columnId ? filters.columnId.toString() : undefined
        };
        return this.postgresqlAdapter.getTasks(postgresFilters);
    }
    async updateTask(id, updates) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.updateTask(id.toString(), updates);
    }
    async deleteTask(id) {
        await this.ensureInitialized();
        return this.postgresqlAdapter.deleteTask(id.toString());
    }
    // === СЛУЖЕБНЫЕ МЕТОДЫ ===
    /**
   * Проверка состояния адаптера
   */ isReady() {
        return this.isInitialized;
    }
    /**
   * Получение статистики использования
   */ async getStats() {
        return {
            isInitialized: this.isInitialized,
            adapterType: 'PostgreSQL Optimized',
            connectionStatus: this.isInitialized ? 'Connected' : 'Disconnected'
        };
    }
    /**
   * Очистка ресурсов
   */ async cleanup() {
        if (this.isInitialized) {
            await this.postgresqlAdapter.close();
            this.isInitialized = false;
            this.initializationPromise = null;
            console.log('✅ Database Adapter очищен');
        }
    }
    /**
   * Полная переинициализация адаптера
   */ async reinitialize() {
        await this.cleanup();
        await this.initialize();
    }
    /**
   * Выполнение сырого SQL запроса (для совместимости с PostgreSQL API)
   */ async executeRawQuery(sql, params) {
        await this.initialize();
        return await this.postgresqlAdapter.query(sql, params);
    }
    /**
   * Выполнение SQL запроса (для совместимости с репозиториями)
   */ async query(sql, params) {
        await this.initialize();
        return await this.postgresqlAdapter.query(sql, params);
    }
}
// Экспортируем singleton instance
const databaseAdapter = DatabaseAdapterOptimized.getInstance();
const __TURBOPACK__default__export__ = databaseAdapter;
;
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
"[project]/src/lib/auth.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname, a: __turbopack_async_module__ } = __turbopack_context__;
__turbopack_async_module__(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {
__turbopack_context__.s({
    "requireAdmin": (()=>requireAdmin),
    "verifyAuth": (()=>verifyAuth),
    "verifyProjectAccess": (()=>verifyProjectAccess)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jsonwebtoken/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2d$optimized$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/database-adapter-optimized.ts [app-route] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2d$optimized$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__
]);
([__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2d$optimized$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__);
;
;
async function verifyAuth(request) {
    try {
        // Получение токена из cookie или заголовка Authorization
        const token = request.cookies.get('auth-token')?.value || request.headers.get('authorization')?.replace('Bearer ', '');
        console.log('Auth token found:', !!token);
        if (!token) {
            console.log('No auth token found in cookies or headers');
            return {
                success: false,
                error: 'Токен аутентификации не найден'
            };
        }
        // Проверка JWT токена
        let decoded;
        try {
            decoded = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].verify(token, process.env.JWT_SECRET || 'your-secret-key');
            console.log('JWT verified successfully for user:', decoded.userId);
        } catch (jwtError) {
            console.log('JWT verification failed:', jwtError);
            return {
                success: false,
                error: 'Невалидный токен'
            };
        }
        // Используем оптимизированный адаптер для работы с сессиями
        await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2d$optimized$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].initialize();
        try {
            // Ищем сессию через адаптер
            const session = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2d$optimized$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].getSessionByToken(token);
            console.log('Session found:', !!session);
            if (!session) {
                console.log('Session not found or expired for token');
                return {
                    success: false,
                    error: 'Сессия не найдена или истекла'
                };
            }
            // Получаем пользователя через адаптер
            const user = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2d$optimized$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].getUserById(session.userId);
            if (!user) {
                return {
                    success: false,
                    error: 'Пользователь не найден'
                };
            }
            // Проверяем статус одобрения пользователя
            // Используем approval_status для PostgreSQL
            const isApproved = user.isApproved !== undefined ? user.isApproved : true;
            if (!isApproved && user.role !== 'admin') {
                return {
                    success: false,
                    error: 'Пользователь не одобрен'
                };
            }
            return {
                success: true,
                user: {
                    userId: String(user.id),
                    email: user.email,
                    role: user.role,
                    name: user.name
                }
            };
        } catch (error) {
            console.error('Auth error:', error);
            return {
                success: false,
                error: 'Ошибка аутентификации'
            };
        }
    } catch (error) {
        console.error('Ошибка проверки аутентификации:', error);
        return {
            success: false,
            error: 'Внутренняя ошибка сервера'
        };
    }
}
async function verifyProjectAccess(userId, projectId, requiredRole) {
    try {
        await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2d$optimized$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].initialize();
        // Получаем проекты через адаптер
        const projects = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2d$optimized$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].getAllProjects();
        const project = projects.find((p)=>p.id === projectId);
        if (!project) {
            return {
                hasAccess: false
            };
        }
        // Проверяем, является ли пользователь владельцем
        if (project.createdBy === userId) {
            return {
                hasAccess: true,
                userRole: 'owner'
            };
        }
        // Получаем участников проекта через getUserProjects
        const userProjects = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2d$optimized$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].getUserProjects(userId);
        const hasAccess = userProjects.some((p)=>p.id === projectId);
        if (!hasAccess) {
            return {
                hasAccess: false
            };
        }
        // Для упрощения, считаем что у пользователя есть доступ как участник
        const userRole = 'member';
        // Проверка требуемой роли
        if (requiredRole) {
            const roleHierarchy = {
                owner: 3,
                admin: 2,
                member: 1
            };
            const userRoleLevel = roleHierarchy[userRole] || 0;
            const requiredRoleLevel = roleHierarchy[requiredRole];
            if (userRoleLevel < requiredRoleLevel) {
                return {
                    hasAccess: false,
                    userRole
                };
            }
        }
        return {
            hasAccess: true,
            userRole
        };
    } catch (error) {
        console.error('Ошибка проверки доступа к проекту:', error);
        return {
            hasAccess: false
        };
    }
}
async function requireAdmin(request) {
    const authResult = await verifyAuth(request);
    if (!authResult.success) {
        return {
            success: false,
            error: authResult.error
        };
    }
    if (authResult.user.role !== 'admin') {
        return {
            success: false,
            error: 'Требуются права администратора'
        };
    }
    return {
        success: true,
        user: authResult.user
    };
}
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
"[project]/src/services/implementations/board.service.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Реализация сервиса для управления досками
 * Следует принципам SOLID и использует Dependency Injection
 */ __turbopack_context__.s({
    "BoardService": (()=>BoardService)
});
class BoardService {
    boardRepository;
    boardValidator;
    permissionService;
    eventService;
    cacheService;
    constructor(boardRepository, boardValidator, permissionService, eventService, cacheService){
        this.boardRepository = boardRepository;
        this.boardValidator = boardValidator;
        this.permissionService = permissionService;
        this.eventService = eventService;
        this.cacheService = cacheService;
    }
    async getBoardById(id, userId) {
        try {
            // Проверяем права доступа
            const canView = await this.permissionService.canUserViewBoard(id, userId);
            if (!canView) {
                return {
                    success: false,
                    error: 'Access denied: You do not have permission to view this board'
                };
            }
            // Пытаемся получить из кэша
            let board = null;
            if (this.cacheService) {
                board = await this.cacheService.getBoard(id);
            }
            // Если не в кэше, получаем из репозитория
            if (!board) {
                board = await this.boardRepository.findById(id);
                if (board && this.cacheService) {
                    await this.cacheService.setBoard(board);
                }
            }
            if (!board) {
                return {
                    success: false,
                    error: 'Board not found'
                };
            }
            return {
                success: true,
                data: board
            };
        } catch (error) {
            return {
                success: false,
                error: `Failed to get board: ${error instanceof Error ? error.message : 'Unknown error'}`
            };
        }
    }
    async getBoardsByProject(projectId, userId, filters) {
        try {
            // Пытаемся получить из кэша
            let boards = null;
            if (this.cacheService && !filters) {
                boards = await this.cacheService.getBoardsByProject(projectId);
            }
            // Если не в кэше, получаем из репозитория
            if (!boards) {
                boards = await this.boardRepository.findByProjectId(projectId, filters);
                if (this.cacheService && !filters) {
                    await this.cacheService.setBoardsByProject(projectId, boards);
                }
            }
            // Фильтруем доски по правам доступа
            const accessibleBoards = [];
            for (const board of boards){
                const canView = await this.permissionService.canUserViewBoard(board.id, userId);
                if (canView) {
                    accessibleBoards.push(board);
                }
            }
            return {
                success: true,
                data: accessibleBoards
            };
        } catch (error) {
            return {
                success: false,
                error: `Failed to get boards: ${error instanceof Error ? error.message : 'Unknown error'}`
            };
        }
    }
    async getAllBoards(userId, filters, sort, pagination) {
        try {
            const result = await this.boardRepository.findAll(filters, sort, pagination);
            // Фильтруем доски по правам доступа
            const accessibleBoards = [];
            for (const board of result.data){
                const canView = await this.permissionService.canUserViewBoard(board.id, userId);
                if (canView) {
                    accessibleBoards.push(board);
                }
            }
            return {
                success: true,
                data: {
                    ...result,
                    data: accessibleBoards,
                    pagination: {
                        ...result.pagination,
                        total: accessibleBoards.length
                    }
                }
            };
        } catch (error) {
            return {
                success: false,
                error: `Failed to get all boards: ${error instanceof Error ? error.message : 'Unknown error'}`
            };
        }
    }
    async createBoard(boardData, userId) {
        try {
            // Проверяем права на создание доски
            const canCreate = await this.permissionService.canUserCreateBoard(boardData.projectId, userId);
            if (!canCreate) {
                return {
                    success: false,
                    error: 'Access denied: You do not have permission to create boards in this project'
                };
            }
            // Валидируем данные
            const validationResult = await this.boardValidator.validateCreateData(boardData);
            if (!validationResult.success) {
                return validationResult;
            }
            // Создаем доску
            const board = await this.boardRepository.create({
                ...boardData,
                createdBy: userId
            });
            // Инвалидируем кэш проекта
            if (this.cacheService) {
                await this.cacheService.invalidateProjectBoards(boardData.projectId);
            }
            // Отправляем событие
            await this.eventService.emitBoardCreated(board, userId);
            return {
                success: true,
                data: board
            };
        } catch (error) {
            return {
                success: false,
                error: `Failed to create board: ${error instanceof Error ? error.message : 'Unknown error'}`
            };
        }
    }
    async updateBoard(id, boardData, userId) {
        try {
            // Проверяем права на редактирование
            const canEdit = await this.permissionService.canUserEditBoard(id, userId);
            if (!canEdit) {
                return {
                    success: false,
                    error: 'Access denied: You do not have permission to edit this board'
                };
            }
            // Получаем существующую доску
            const existingBoard = await this.boardRepository.findById(id);
            if (!existingBoard) {
                return {
                    success: false,
                    error: 'Board not found'
                };
            }
            // Валидируем данные
            const validationResult = await this.boardValidator.validateUpdateData(boardData, existingBoard);
            if (!validationResult.success) {
                return validationResult;
            }
            // Обновляем доску
            const updatedBoard = await this.boardRepository.update(id, boardData, userId);
            if (!updatedBoard) {
                return {
                    success: false,
                    error: 'Failed to update board'
                };
            }
            // Обновляем кэш
            if (this.cacheService) {
                await this.cacheService.setBoard(updatedBoard);
                await this.cacheService.invalidateProjectBoards(updatedBoard.projectId);
            }
            // Отправляем событие
            await this.eventService.emitBoardUpdated(updatedBoard, userId, boardData);
            return {
                success: true,
                data: updatedBoard
            };
        } catch (error) {
            return {
                success: false,
                error: `Failed to update board: ${error instanceof Error ? error.message : 'Unknown error'}`
            };
        }
    }
    async deleteBoard(id, userId) {
        try {
            // Проверяем права на удаление
            const canDelete = await this.permissionService.canUserDeleteBoard(id, userId);
            if (!canDelete) {
                return {
                    success: false,
                    error: 'Access denied: You do not have permission to delete this board'
                };
            }
            // Получаем доску для получения projectId
            const board = await this.boardRepository.findById(id);
            if (!board) {
                return {
                    success: false,
                    error: 'Board not found'
                };
            }
            // Удаляем доску
            const deleted = await this.boardRepository.delete(id);
            if (!deleted) {
                return {
                    success: false,
                    error: 'Failed to delete board'
                };
            }
            // Очищаем кэш
            if (this.cacheService) {
                await this.cacheService.deleteBoard(id);
                await this.cacheService.invalidateProjectBoards(board.projectId);
            }
            // Отправляем событие
            await this.eventService.emitBoardDeleted(id, userId);
            return {
                success: true,
                data: true
            };
        } catch (error) {
            return {
                success: false,
                error: `Failed to delete board: ${error instanceof Error ? error.message : 'Unknown error'}`
            };
        }
    }
    async archiveBoard(id, userId) {
        try {
            // Проверяем права на архивирование
            const canEdit = await this.permissionService.canUserEditBoard(id, userId);
            if (!canEdit) {
                return {
                    success: false,
                    error: 'Access denied: You do not have permission to archive this board'
                };
            }
            // Получаем доску для получения projectId
            const board = await this.boardRepository.findById(id);
            if (!board) {
                return {
                    success: false,
                    error: 'Board not found'
                };
            }
            // Архивируем доску
            const archived = await this.boardRepository.archive(id, userId);
            if (!archived) {
                return {
                    success: false,
                    error: 'Failed to archive board'
                };
            }
            // Обновляем кэш
            if (this.cacheService) {
                await this.cacheService.deleteBoard(id);
                await this.cacheService.invalidateProjectBoards(board.projectId);
            }
            // Отправляем событие
            await this.eventService.emitBoardArchived(id, userId);
            return {
                success: true,
                data: true
            };
        } catch (error) {
            return {
                success: false,
                error: `Failed to archive board: ${error instanceof Error ? error.message : 'Unknown error'}`
            };
        }
    }
    async restoreBoard(id, userId) {
        try {
            // Проверяем права на восстановление
            const canEdit = await this.permissionService.canUserEditBoard(id, userId);
            if (!canEdit) {
                return {
                    success: false,
                    error: 'Access denied: You do not have permission to restore this board'
                };
            }
            // Получаем доску для получения projectId
            const board = await this.boardRepository.findById(id);
            if (!board) {
                return {
                    success: false,
                    error: 'Board not found'
                };
            }
            // Восстанавливаем доску
            const restored = await this.boardRepository.restore(id, userId);
            if (!restored) {
                return {
                    success: false,
                    error: 'Failed to restore board'
                };
            }
            // Инвалидируем кэш
            if (this.cacheService) {
                await this.cacheService.invalidateProjectBoards(board.projectId);
            }
            return {
                success: true,
                data: true
            };
        } catch (error) {
            return {
                success: false,
                error: `Failed to restore board: ${error instanceof Error ? error.message : 'Unknown error'}`
            };
        }
    }
    async reorderBoards(projectId, boardIds, userId) {
        try {
            // Проверяем права на редактирование досок в проекте
            const canCreate = await this.permissionService.canUserCreateBoard(projectId, userId);
            if (!canCreate) {
                return {
                    success: false,
                    error: 'Access denied: You do not have permission to reorder boards in this project'
                };
            }
            // Обновляем позиции досок
            const updates = boardIds.map((boardId, index)=>({
                    id: boardId,
                    position: index + 1
                }));
            for (const update of updates){
                await this.boardRepository.updatePosition(update.id, update.position);
            }
            // Инвалидируем кэш
            if (this.cacheService) {
                await this.cacheService.invalidateProjectBoards(projectId);
            }
            return {
                success: true,
                data: true
            };
        } catch (error) {
            return {
                success: false,
                error: `Failed to reorder boards: ${error instanceof Error ? error.message : 'Unknown error'}`
            };
        }
    }
    async duplicateBoard(id, newName, userId) {
        try {
            // Получаем исходную доску
            const originalBoard = await this.boardRepository.findById(id);
            if (!originalBoard) {
                return {
                    success: false,
                    error: 'Original board not found'
                };
            }
            // Проверяем права на просмотр исходной доски
            const canView = await this.permissionService.canUserViewBoard(id, userId);
            if (!canView) {
                return {
                    success: false,
                    error: 'Access denied: You do not have permission to view the original board'
                };
            }
            // Проверяем права на создание доски в проекте
            const canCreate = await this.permissionService.canUserCreateBoard(originalBoard.projectId, userId);
            if (!canCreate) {
                return {
                    success: false,
                    error: 'Access denied: You do not have permission to create boards in this project'
                };
            }
            // Создаем дубликат
            const duplicateData = {
                name: newName,
                description: originalBoard.description,
                projectId: originalBoard.projectId,
                visibility: originalBoard.visibility,
                settings: originalBoard.settings,
                icon: originalBoard.icon,
                color: originalBoard.color
            };
            return await this.createBoard(duplicateData, userId);
        } catch (error) {
            return {
                success: false,
                error: `Failed to duplicate board: ${error instanceof Error ? error.message : 'Unknown error'}`
            };
        }
    }
    async getBoardStatistics(id, userId) {
        try {
            // Проверяем права доступа
            const canView = await this.permissionService.canUserViewBoard(id, userId);
            if (!canView) {
                return {
                    success: false,
                    error: 'Access denied: You do not have permission to view this board'
                };
            }
            // Здесь будет логика получения статистики
            // Пока возвращаем заглушку
            const statistics = {
                totalTasks: 0,
                completedTasks: 0,
                inProgressTasks: 0,
                todoTasks: 0,
                totalColumns: 0
            };
            return {
                success: true,
                data: statistics
            };
        } catch (error) {
            return {
                success: false,
                error: `Failed to get board statistics: ${error instanceof Error ? error.message : 'Unknown error'}`
            };
        }
    }
    async getUserPermissions(boardId, userId) {
        try {
            const permissions = await this.permissionService.getUserPermissions(boardId, userId);
            return {
                success: true,
                data: permissions
            };
        } catch (error) {
            return {
                success: false,
                error: `Failed to get user permissions: ${error instanceof Error ? error.message : 'Unknown error'}`
            };
        }
    }
    async getBoardEvents(boardId, userId, limit) {
        try {
            // Проверяем права доступа
            const canView = await this.permissionService.canUserViewBoard(boardId, userId);
            if (!canView) {
                return {
                    success: false,
                    error: 'Access denied: You do not have permission to view this board'
                };
            }
            const events = await this.eventService.getBoardEvents(boardId, limit);
            return {
                success: true,
                data: events
            };
        } catch (error) {
            return {
                success: false,
                error: `Failed to get board events: ${error instanceof Error ? error.message : 'Unknown error'}`
            };
        }
    }
}
}}),
"[project]/src/services/implementations/board.repository.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Реализация репозитория для досок
 * Отвечает только за операции с данными (Single Responsibility)
 */ __turbopack_context__.s({
    "BoardRepository": (()=>BoardRepository)
});
class BoardRepository {
    databaseAdapter;
    constructor(databaseAdapter){
        this.databaseAdapter = databaseAdapter;
    }
    async findById(id) {
        try {
            const query = `
        SELECT 
          id,
          name,
          description,
          project_id as projectId,
          visibility,
          settings,
          icon,
          color,
          position,
          created_by as createdBy,
          updated_by as updatedBy,
          created_at as createdAt,
          updated_at as updatedAt,
          is_archived as isArchived,
          archived_at as archivedAt
        FROM boards 
        WHERE id = $1 AND is_archived = FALSE
      `;
            const result = await this.databaseAdapter.query(query, [
                id
            ]);
            if (!result || result.length === 0) {
                return null;
            }
            return this.mapRowToBoard(result[0]);
        } catch (error) {
            console.error('Error finding board by id:', error);
            throw new Error(`Failed to find board: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    async findByProjectId(projectId, filters) {
        try {
            let query = `
        SELECT 
          id,
          name,
          description,
          project_id as projectId,
          visibility,
          settings,
          icon,
          color,
          position,
          created_by as createdBy,
          updated_by as updatedBy,
          created_at as createdAt,
          updated_at as updatedAt,
          is_archived as isArchived,
          archived_at as archivedAt
        FROM boards 
        WHERE project_id = $1
      `;
            const params = [
                projectId
            ];
            let paramIndex = 2;
            // Применяем фильтры
            if (filters) {
                if (filters.visibility) {
                    query += ` AND visibility = $${paramIndex}`;
                    params.push(filters.visibility);
                    paramIndex++;
                }
                if (filters.createdBy) {
                    query += ` AND created_by = $${paramIndex}`;
                    params.push(filters.createdBy);
                    paramIndex++;
                }
                if (filters.isArchived !== undefined) {
                    query += ` AND is_archived = $${paramIndex}`;
                    params.push(filters.isArchived);
                    paramIndex++;
                } else {
                    query += ' AND is_archived = FALSE';
                }
                if (filters.search) {
                    query += ` AND (name LIKE $${paramIndex} OR description LIKE $${paramIndex + 1})`;
                    const searchTerm = `%${filters.search}%`;
                    params.push(searchTerm, searchTerm);
                    paramIndex += 2;
                }
            } else {
                query += ' AND is_archived = FALSE';
            }
            query += ' ORDER BY position ASC, created_at DESC';
            const results = await this.databaseAdapter.query(query, params);
            return results.map((row)=>this.mapRowToBoard(row));
        } catch (error) {
            console.error('Error finding boards by project:', error);
            throw new Error(`Failed to find boards: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    async findAll(filters, sort, pagination) {
        try {
            let query = `
        SELECT 
          id,
          name,
          description,
          project_id as projectId,
          visibility,
          settings,
          icon,
          color,
          position,
          created_by as createdBy,
          updated_by as updatedBy,
          created_at as createdAt,
          updated_at as updatedAt,
          is_archived as isArchived,
          archived_at as archivedAt
        FROM boards 
        WHERE 1=1
      `;
            const params = [];
            let paramIndex = 1;
            // Применяем фильтры
            if (filters) {
                if (filters.projectId) {
                    query += ` AND project_id = $${paramIndex++}`;
                    params.push(filters.projectId);
                }
                if (filters.visibility) {
                    query += ` AND visibility = $${paramIndex++}`;
                    params.push(filters.visibility);
                }
                if (filters.createdBy) {
                    query += ` AND created_by = $${paramIndex++}`;
                    params.push(filters.createdBy);
                }
                if (filters.isArchived !== undefined) {
                    query += ` AND is_archived = $${paramIndex++}`;
                    params.push(filters.isArchived);
                } else {
                    query += ' AND is_archived = FALSE';
                }
                if (filters.search) {
                    query += ` AND (name LIKE $${paramIndex++} OR description LIKE $${paramIndex++})`;
                    const searchTerm = `%${filters.search}%`;
                    params.push(searchTerm, searchTerm);
                }
            } else {
                query += ' AND is_archived = FALSE';
            }
            // Применяем сортировку
            if (sort) {
                const sortField = this.mapSortField(sort.field);
                query += ` ORDER BY ${sortField} ${sort.direction.toUpperCase()}`;
            } else {
                query += ' ORDER BY position ASC, created_at DESC';
            }
            // Подсчитываем общее количество
            const countQuery = query.replace(/SELECT[\s\S]*?FROM/, 'SELECT COUNT(*) as total FROM');
            const countResult = await this.databaseAdapter.query(countQuery, params);
            const total = countResult[0]?.total || 0;
            // Применяем пагинацию
            if (pagination) {
                const offset = (pagination.page - 1) * pagination.limit;
                query += ` LIMIT $${paramIndex++} OFFSET $${paramIndex++}`;
                params.push(pagination.limit, offset);
            }
            const results = await this.databaseAdapter.query(query, params);
            const boards = results.map((row)=>this.mapRowToBoard(row));
            const totalPages = pagination ? Math.ceil(total / pagination.limit) : 1;
            const currentPage = pagination?.page || 1;
            return {
                data: boards,
                pagination: {
                    page: currentPage,
                    limit: pagination?.limit || total,
                    total,
                    totalPages,
                    hasNext: currentPage < totalPages,
                    hasPrev: currentPage > 1
                }
            };
        } catch (error) {
            console.error('Error finding all boards:', error);
            throw new Error(`Failed to find boards: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    async create(boardData) {
        try {
            const id = this.generateId();
            const now = new Date();
            const position = await this.getMaxPosition(boardData.projectId) + 1;
            const defaultSettings = {
                allowTaskCreation: true,
                allowColumnReordering: true,
                enableTaskLimits: false,
                defaultTaskPriority: 'medium',
                autoArchiveCompletedTasks: false,
                ...boardData.settings
            };
            const query = `
        INSERT INTO boards (
          id, name, description, project_id, visibility, settings, 
          icon, color, position, created_by, created_at, updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
      `;
            const params = [
                id,
                boardData.name,
                boardData.description || null,
                boardData.projectId,
                boardData.visibility || 'team',
                JSON.stringify(defaultSettings),
                boardData.icon || null,
                boardData.color || '#3B82F6',
                position,
                boardData.createdBy,
                now,
                now
            ];
            await this.databaseAdapter.query(query, params);
            // Создаем колонки по умолчанию
            await this.createDefaultColumns(id, boardData.createdBy);
            const createdBoard = await this.findById(id);
            if (!createdBoard) {
                throw new Error('Failed to retrieve created board');
            }
            return createdBoard;
        } catch (error) {
            console.error('Error creating board:', error);
            throw new Error(`Failed to create board: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    async update(id, boardData, updatedBy) {
        try {
            const updateFields = [];
            const params = [];
            let paramIndex = 1;
            if (boardData.name !== undefined) {
                updateFields.push(`name = $${paramIndex++}`);
                params.push(boardData.name);
            }
            if (boardData.description !== undefined) {
                updateFields.push(`description = $${paramIndex++}`);
                params.push(boardData.description);
            }
            if (boardData.visibility !== undefined) {
                updateFields.push(`visibility = $${paramIndex++}`);
                params.push(boardData.visibility);
            }
            if (boardData.settings !== undefined) {
                // Получаем текущие настройки и объединяем с новыми
                const currentBoard = await this.findById(id);
                if (currentBoard) {
                    const updatedSettings = {
                        ...currentBoard.settings,
                        ...boardData.settings
                    };
                    updateFields.push(`settings = $${paramIndex++}`);
                    params.push(JSON.stringify(updatedSettings));
                }
            }
            if (boardData.icon !== undefined) {
                updateFields.push(`icon = $${paramIndex++}`);
                params.push(boardData.icon);
            }
            if (boardData.color !== undefined) {
                updateFields.push(`color = $${paramIndex++}`);
                params.push(boardData.color);
            }
            if (boardData.position !== undefined) {
                updateFields.push(`position = $${paramIndex++}`);
                params.push(boardData.position);
            }
            if (updateFields.length === 0) {
                return await this.findById(id);
            }
            updateFields.push(`updated_by = $${paramIndex++}`, `updated_at = $${paramIndex++}`);
            params.push(updatedBy, new Date());
            params.push(id);
            const query = `UPDATE boards SET ${updateFields.join(', ')} WHERE id = $${paramIndex}`;
            await this.databaseAdapter.query(query, params);
            return await this.findById(id);
        } catch (error) {
            console.error('Error updating board:', error);
            throw new Error(`Failed to update board: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    async delete(id) {
        try {
            // Сначала удаляем все связанные данные (задачи, колонки)
            await this.databaseAdapter.query('DELETE FROM tasks WHERE board_id = $1', [
                id
            ]);
            await this.databaseAdapter.query('DELETE FROM columns WHERE board_id = $1', [
                id
            ]);
            // Затем удаляем саму доску
            const query = 'DELETE FROM boards WHERE id = $1';
            const result = await this.databaseAdapter.query(query, [
                id
            ]);
            return result.affectedRows > 0;
        } catch (error) {
            console.error('Error deleting board:', error);
            throw new Error(`Failed to delete board: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    async archive(id, archivedBy) {
        try {
            const query = `
        UPDATE boards 
        SET is_archived = TRUE, archived_at = $1, updated_by = $2, updated_at = $3
        WHERE id = $4
      `;
            const now = new Date();
            const result = await this.databaseAdapter.query(query, [
                now,
                archivedBy,
                now,
                id
            ]);
            return result.affectedRows > 0;
        } catch (error) {
            console.error('Error archiving board:', error);
            throw new Error(`Failed to archive board: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    async restore(id, restoredBy) {
        try {
            const query = `
        UPDATE boards 
        SET is_archived = FALSE, archived_at = NULL, updated_by = $1, updated_at = $2
        WHERE id = $3
      `;
            const now = new Date();
            const result = await this.databaseAdapter.query(query, [
                restoredBy,
                now,
                id
            ]);
            return result.affectedRows > 0;
        } catch (error) {
            console.error('Error restoring board:', error);
            throw new Error(`Failed to restore board: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    async updatePosition(id, newPosition) {
        try {
            const query = 'UPDATE boards SET position = $1, updated_at = $2 WHERE id = $3';
            const result = await this.databaseAdapter.query(query, [
                newPosition,
                new Date(),
                id
            ]);
            return result.affectedRows > 0;
        } catch (error) {
            console.error('Error updating board position:', error);
            throw new Error(`Failed to update board position: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    async getMaxPosition(projectId) {
        try {
            const query = 'SELECT MAX(position) as maxPosition FROM boards WHERE project_id = $1 AND is_archived = FALSE';
            const result = await this.databaseAdapter.query(query, [
                projectId
            ]);
            return result[0]?.maxPosition || 0;
        } catch (error) {
            console.error('Error getting max position:', error);
            return 0;
        }
    }
    async existsByName(name, projectId, excludeId) {
        try {
            let query = 'SELECT COUNT(*) as count FROM boards WHERE name = $1 AND project_id = $2 AND is_archived = FALSE';
            const params = [
                name,
                projectId
            ];
            if (excludeId) {
                query += ' AND id != $3';
                params.push(excludeId);
            }
            const result = await this.databaseAdapter.query(query, params);
            return result[0]?.count > 0;
        } catch (error) {
            console.error('Error checking board name existence:', error);
            return false;
        }
    }
    async countByProject(projectId) {
        try {
            const query = 'SELECT COUNT(*) as count FROM boards WHERE project_id = $1 AND is_archived = FALSE';
            const result = await this.databaseAdapter.query(query, [
                projectId
            ]);
            return result[0]?.count || 0;
        } catch (error) {
            console.error('Error counting boards by project:', error);
            return 0;
        }
    }
    async createDefaultColumns(boardId, createdBy) {
        const defaultColumns = [
            {
                title: 'To Do',
                color: '#EF4444',
                position: 1
            },
            {
                title: 'In Progress',
                color: '#F59E0B',
                position: 2
            },
            {
                title: 'Review',
                color: '#3B82F6',
                position: 3
            },
            {
                title: 'Done',
                color: '#10B981',
                position: 4
            }
        ];
        const now = new Date();
        for (const column of defaultColumns){
            const columnId = this.generateId();
            const query = `
        INSERT INTO columns (
          id, title, board_id, position, color, settings, 
          created_by, created_at, updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
      `;
            const defaultColumnSettings = {
                allowTaskCreation: true,
                autoMoveRules: []
            };
            await this.databaseAdapter.query(query, [
                columnId,
                column.title,
                boardId,
                column.position,
                column.color,
                JSON.stringify(defaultColumnSettings),
                createdBy,
                now,
                now
            ]);
        }
    }
    mapRowToBoard(row) {
        return {
            id: row.id,
            name: row.name,
            description: row.description,
            projectId: row.projectId,
            visibility: row.visibility,
            settings: typeof row.settings === 'string' ? JSON.parse(row.settings) : row.settings,
            icon: row.icon,
            color: row.color,
            position: row.position,
            createdBy: row.createdBy,
            updatedBy: row.updatedBy,
            createdAt: new Date(row.createdAt),
            updatedAt: new Date(row.updatedAt),
            isArchived: Boolean(row.isArchived),
            archivedAt: row.archivedAt ? new Date(row.archivedAt) : undefined
        };
    }
    mapSortField(field) {
        const fieldMap = {
            'createdAt': 'created_at',
            'updatedAt': 'updated_at',
            'priority': 'position',
            'deadline': 'created_at',
            'position': 'position',
            'title': 'name'
        };
        return fieldMap[field] || 'created_at';
    }
    generateId() {
        // Import crypto for UUID generation
        const crypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
        return crypto.randomUUID();
    }
}
}}),
"[project]/src/services/implementations/board.validator.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Валидатор для досок
 * Отвечает только за валидацию данных (Single Responsibility)
 */ __turbopack_context__.s({
    "BoardValidator": (()=>BoardValidator)
});
class BoardValidator {
    async validateCreate(data) {
        const errors = [];
        // Валидация названия
        const nameValidation = this.validateName(data.name);
        if (!nameValidation.isValid) {
            errors.push(...nameValidation.errors);
        }
        // Валидация проекта
        const projectValidation = this.validateProjectId(data.projectId);
        if (!projectValidation.isValid) {
            errors.push(...projectValidation.errors);
        }
        // Валидация описания
        if (data.description !== undefined) {
            const descriptionValidation = this.validateDescription(data.description);
            if (!descriptionValidation.isValid) {
                errors.push(...descriptionValidation.errors);
            }
        }
        // Валидация видимости
        if (data.visibility !== undefined) {
            const visibilityValidation = this.validateVisibility(data.visibility);
            if (!visibilityValidation.isValid) {
                errors.push(...visibilityValidation.errors);
            }
        }
        // Валидация цвета
        if (data.color !== undefined) {
            const colorValidation = this.validateColor(data.color);
            if (!colorValidation.isValid) {
                errors.push(...colorValidation.errors);
            }
        }
        // Валидация иконки
        if (data.icon !== undefined) {
            const iconValidation = this.validateIcon(data.icon);
            if (!iconValidation.isValid) {
                errors.push(...iconValidation.errors);
            }
        }
        // Валидация настроек
        if (data.settings !== undefined) {
            const settingsValidation = this.validateSettings(data.settings);
            if (!settingsValidation.isValid) {
                errors.push(...settingsValidation.errors);
            }
        }
        return {
            isValid: errors.length === 0,
            errors
        };
    }
    async validateCreateData(data) {
        const validationResult = await this.validateCreate(data);
        if (validationResult.isValid) {
            return {
                success: true
            };
        }
        const errorMessages = validationResult.errors.map((error)=>error.message).join(', ');
        return {
            success: false,
            error: errorMessages
        };
    }
    async validateUpdate(id, data) {
        const errors = [];
        // Валидация ID
        const idValidation = this.validateId(id);
        if (!idValidation.isValid) {
            errors.push(...idValidation.errors);
        }
        // Валидация названия (если предоставлено)
        if (data.name !== undefined) {
            const nameValidation = this.validateName(data.name);
            if (!nameValidation.isValid) {
                errors.push(...nameValidation.errors);
            }
        }
        // Валидация описания (если предоставлено)
        if (data.description !== undefined) {
            const descriptionValidation = this.validateDescription(data.description);
            if (!descriptionValidation.isValid) {
                errors.push(...descriptionValidation.errors);
            }
        }
        // Валидация видимости (если предоставлено)
        if (data.visibility !== undefined) {
            const visibilityValidation = this.validateVisibility(data.visibility);
            if (!visibilityValidation.isValid) {
                errors.push(...visibilityValidation.errors);
            }
        }
        // Валидация цвета (если предоставлено)
        if (data.color !== undefined) {
            const colorValidation = this.validateColor(data.color);
            if (!colorValidation.isValid) {
                errors.push(...colorValidation.errors);
            }
        }
        // Валидация иконки (если предоставлено)
        if (data.icon !== undefined) {
            const iconValidation = this.validateIcon(data.icon);
            if (!iconValidation.isValid) {
                errors.push(...iconValidation.errors);
            }
        }
        // Валидация позиции (если предоставлено)
        if (data.position !== undefined) {
            const positionValidation = this.validatePosition(data.position);
            if (!positionValidation.isValid) {
                errors.push(...positionValidation.errors);
            }
        }
        // Валидация настроек (если предоставлено)
        if (data.settings !== undefined) {
            const settingsValidation = this.validateSettings(data.settings);
            if (!settingsValidation.isValid) {
                errors.push(...settingsValidation.errors);
            }
        }
        return {
            isValid: errors.length === 0,
            errors
        };
    }
    async validateDelete(id) {
        const errors = [];
        // Валидация ID
        const idValidation = this.validateId(id);
        if (!idValidation.isValid) {
            errors.push(...idValidation.errors);
        }
        return {
            isValid: errors.length === 0,
            errors
        };
    }
    async validateArchive(id) {
        return this.validateDelete(id); // Те же правила валидации
    }
    async validateRestore(id) {
        return this.validateDelete(id); // Те же правила валидации
    }
    async validateReorder(boardIds, positions) {
        const errors = [];
        // Проверяем, что количество досок и позиций совпадает
        if (boardIds.length !== positions.length) {
            errors.push({
                field: 'reorder',
                message: 'Количество досок и позиций должно совпадать',
                code: 'REORDER_MISMATCH'
            });
        }
        // Валидация каждого ID доски
        for (const id of boardIds){
            const idValidation = this.validateId(id);
            if (!idValidation.isValid) {
                errors.push(...idValidation.errors);
            }
        }
        // Валидация каждой позиции
        for (const position of positions){
            const positionValidation = this.validatePosition(position);
            if (!positionValidation.isValid) {
                errors.push(...positionValidation.errors);
            }
        }
        // Проверяем уникальность позиций
        const uniquePositions = new Set(positions);
        if (uniquePositions.size !== positions.length) {
            errors.push({
                field: 'positions',
                message: 'Позиции должны быть уникальными',
                code: 'DUPLICATE_POSITIONS'
            });
        }
        return {
            isValid: errors.length === 0,
            errors
        };
    }
    async validateDuplicate(id, newName) {
        const errors = [];
        // Валидация исходного ID
        const idValidation = this.validateId(id);
        if (!idValidation.isValid) {
            errors.push(...idValidation.errors);
        }
        // Валидация нового названия (если предоставлено)
        if (newName !== undefined) {
            const nameValidation = this.validateName(newName);
            if (!nameValidation.isValid) {
                errors.push(...nameValidation.errors);
            }
        }
        return {
            isValid: errors.length === 0,
            errors
        };
    }
    // Приватные методы для валидации отдельных полей
    validateId(id) {
        const errors = [];
        if (!id) {
            errors.push({
                field: 'id',
                message: 'ID доски обязателен',
                code: 'REQUIRED'
            });
        } else if (typeof id !== 'string') {
            errors.push({
                field: 'id',
                message: 'ID доски должен быть строкой',
                code: 'INVALID_TYPE'
            });
        } else if (id.trim().length === 0) {
            errors.push({
                field: 'id',
                message: 'ID доски не может быть пустым',
                code: 'EMPTY'
            });
        }
        return {
            isValid: errors.length === 0,
            errors
        };
    }
    validateName(name) {
        const errors = [];
        if (!name) {
            errors.push({
                field: 'name',
                message: 'Название доски обязательно',
                code: 'REQUIRED'
            });
        } else if (typeof name !== 'string') {
            errors.push({
                field: 'name',
                message: 'Название доски должно быть строкой',
                code: 'INVALID_TYPE'
            });
        } else {
            const trimmedName = name.trim();
            if (trimmedName.length === 0) {
                errors.push({
                    field: 'name',
                    message: 'Название доски не может быть пустым',
                    code: 'EMPTY'
                });
            } else if (trimmedName.length < 2) {
                errors.push({
                    field: 'name',
                    message: 'Название доски должно содержать минимум 2 символа',
                    code: 'TOO_SHORT'
                });
            } else if (trimmedName.length > 100) {
                errors.push({
                    field: 'name',
                    message: 'Название доски не может превышать 100 символов',
                    code: 'TOO_LONG'
                });
            }
            // Проверка на недопустимые символы
            const invalidChars = /[<>"'&]/;
            if (invalidChars.test(trimmedName)) {
                errors.push({
                    field: 'name',
                    message: 'Название доски содержит недопустимые символы',
                    code: 'INVALID_CHARACTERS'
                });
            }
        }
        return {
            isValid: errors.length === 0,
            errors
        };
    }
    validateDescription(description) {
        const errors = [];
        if (description !== null && description !== undefined) {
            if (typeof description !== 'string') {
                errors.push({
                    field: 'description',
                    message: 'Описание доски должно быть строкой',
                    code: 'INVALID_TYPE'
                });
            } else if (description.length > 1000) {
                errors.push({
                    field: 'description',
                    message: 'Описание доски не может превышать 1000 символов',
                    code: 'TOO_LONG'
                });
            }
        }
        return {
            isValid: errors.length === 0,
            errors
        };
    }
    validateProjectId(projectId) {
        const errors = [];
        if (!projectId) {
            errors.push({
                field: 'projectId',
                message: 'ID проекта обязателен',
                code: 'REQUIRED'
            });
        } else if (typeof projectId !== 'string') {
            errors.push({
                field: 'projectId',
                message: 'ID проекта должен быть строкой',
                code: 'INVALID_TYPE'
            });
        } else if (projectId.trim().length === 0) {
            errors.push({
                field: 'projectId',
                message: 'ID проекта не может быть пустым',
                code: 'EMPTY'
            });
        }
        return {
            isValid: errors.length === 0,
            errors
        };
    }
    validateVisibility(visibility) {
        const errors = [];
        const validVisibilities = [
            'private',
            'team',
            'public'
        ];
        if (!validVisibilities.includes(visibility)) {
            errors.push({
                field: 'visibility',
                message: `Видимость доски должна быть одной из: ${validVisibilities.join(', ')}`,
                code: 'INVALID_VALUE'
            });
        }
        return {
            isValid: errors.length === 0,
            errors
        };
    }
    validateColor(color) {
        const errors = [];
        if (typeof color !== 'string') {
            errors.push({
                field: 'color',
                message: 'Цвет доски должен быть строкой',
                code: 'INVALID_TYPE'
            });
        } else {
            // Проверка формата HEX цвета
            const hexColorRegex = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
            if (!hexColorRegex.test(color)) {
                errors.push({
                    field: 'color',
                    message: 'Цвет доски должен быть в формате HEX (#RRGGBB или #RGB)',
                    code: 'INVALID_FORMAT'
                });
            }
        }
        return {
            isValid: errors.length === 0,
            errors
        };
    }
    validateIcon(icon) {
        const errors = [];
        if (icon !== null && icon !== undefined) {
            if (typeof icon !== 'string') {
                errors.push({
                    field: 'icon',
                    message: 'Иконка доски должна быть строкой',
                    code: 'INVALID_TYPE'
                });
            } else if (icon.length > 50) {
                errors.push({
                    field: 'icon',
                    message: 'Иконка доски не может превышать 50 символов',
                    code: 'TOO_LONG'
                });
            }
        }
        return {
            isValid: errors.length === 0,
            errors
        };
    }
    validatePosition(position) {
        const errors = [];
        if (typeof position !== 'number') {
            errors.push({
                field: 'position',
                message: 'Позиция доски должна быть числом',
                code: 'INVALID_TYPE'
            });
        } else if (!Number.isInteger(position)) {
            errors.push({
                field: 'position',
                message: 'Позиция доски должна быть целым числом',
                code: 'INVALID_VALUE'
            });
        } else if (position < 0) {
            errors.push({
                field: 'position',
                message: 'Позиция доски не может быть отрицательной',
                code: 'INVALID_VALUE'
            });
        }
        return {
            isValid: errors.length === 0,
            errors
        };
    }
    validateSettings(settings) {
        const errors = [];
        if (settings !== null && settings !== undefined) {
            if (typeof settings !== 'object') {
                errors.push({
                    field: 'settings',
                    message: 'Настройки доски должны быть объектом',
                    code: 'INVALID_TYPE'
                });
            } else {
                // Валидация конкретных настроек
                if (settings.allowTaskCreation !== undefined && typeof settings.allowTaskCreation !== 'boolean') {
                    errors.push({
                        field: 'settings.allowTaskCreation',
                        message: 'allowTaskCreation должно быть булевым значением',
                        code: 'INVALID_TYPE'
                    });
                }
                if (settings.allowColumnReordering !== undefined && typeof settings.allowColumnReordering !== 'boolean') {
                    errors.push({
                        field: 'settings.allowColumnReordering',
                        message: 'allowColumnReordering должно быть булевым значением',
                        code: 'INVALID_TYPE'
                    });
                }
                if (settings.enableTaskLimits !== undefined && typeof settings.enableTaskLimits !== 'boolean') {
                    errors.push({
                        field: 'settings.enableTaskLimits',
                        message: 'enableTaskLimits должно быть булевым значением',
                        code: 'INVALID_TYPE'
                    });
                }
                if (settings.defaultTaskPriority !== undefined) {
                    const validPriorities = [
                        'low',
                        'medium',
                        'high',
                        'urgent'
                    ];
                    if (!validPriorities.includes(settings.defaultTaskPriority)) {
                        errors.push({
                            field: 'settings.defaultTaskPriority',
                            message: `defaultTaskPriority должно быть одним из: ${validPriorities.join(', ')}`,
                            code: 'INVALID_VALUE'
                        });
                    }
                }
                if (settings.autoArchiveCompletedTasks !== undefined && typeof settings.autoArchiveCompletedTasks !== 'boolean') {
                    errors.push({
                        field: 'settings.autoArchiveCompletedTasks',
                        message: 'autoArchiveCompletedTasks должно быть булевым значением',
                        code: 'INVALID_TYPE'
                    });
                }
            }
        }
        return {
            isValid: errors.length === 0,
            errors
        };
    }
}
}}),
"[project]/src/services/implementations/permission.service.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Реализация сервиса разрешений для досок
 * Управляет правами доступа пользователей к доскам и проектам
 */ __turbopack_context__.s({
    "PermissionService": (()=>PermissionService)
});
class PermissionService {
    databaseAdapter;
    constructor(databaseAdapter){
        this.databaseAdapter = databaseAdapter;
    }
    /**
   * Получает разрешения пользователя для доски
   */ async getUserPermissions(boardId, userId) {
        try {
            // Получаем информацию о доске и проекте
            const boardQuery = `
        SELECT b.project_id, b.created_by, b.visibility,
               p.creator_id as project_owner
        FROM boards b
        JOIN projects p ON b.project_id = p.id
        WHERE b.id = $1
      `;
            const boardResult = await this.databaseAdapter.query(boardQuery, [
                boardId
            ]);
            if (!boardResult.rows || boardResult.rows.length === 0) {
                return {
                    canView: false,
                    canEdit: false,
                    canDelete: false,
                    canManage: false
                };
            }
            const board = boardResult.rows[0];
            // Проверяем членство в проекте
            const memberQuery = `
        SELECT role FROM project_members 
        WHERE project_id = $1 AND user_id = $2
      `;
            const memberResult = await this.databaseAdapter.query(memberQuery, [
                board.project_id,
                userId
            ]);
            const userRole = memberResult.rows?.[0]?.role;
            // Определяем разрешения на основе роли и владения
            const isProjectOwner = board.project_owner === userId;
            const isBoardCreator = board.created_by === userId;
            const isPublicBoard = board.visibility === 'public';
            let canView = false;
            let canEdit = false;
            let canDelete = false;
            let canManage = false;
            if (isProjectOwner) {
                // Владелец проекта имеет все права
                canView = true;
                canEdit = true;
                canDelete = true;
                canManage = true;
            } else if (userRole) {
                // Член проекта
                switch(userRole){
                    case 'admin':
                        canView = true;
                        canEdit = true;
                        canDelete = true;
                        canManage = true;
                        break;
                    case 'member':
                        canView = true;
                        canEdit = true;
                        canDelete = isBoardCreator;
                        canManage = false;
                        break;
                    case 'viewer':
                        canView = true;
                        canEdit = false;
                        canDelete = false;
                        canManage = false;
                        break;
                }
            } else if (isPublicBoard) {
                // Публичная доска - только просмотр
                canView = true;
                canEdit = false;
                canDelete = false;
                canManage = false;
            }
            return {
                canView,
                canEdit,
                canDelete,
                canManage
            };
        } catch (error) {
            console.error('Error getting user permissions:', error);
            return {
                canView: false,
                canEdit: false,
                canDelete: false,
                canManage: false
            };
        }
    }
    /**
   * Проверяет, может ли пользователь просматривать доску
   */ async canUserViewBoard(boardId, userId) {
        const permissions = await this.getUserPermissions(boardId, userId);
        return permissions.canView;
    }
    /**
   * Проверяет, может ли пользователь редактировать доску
   */ async canUserEditBoard(boardId, userId) {
        const permissions = await this.getUserPermissions(boardId, userId);
        return permissions.canEdit;
    }
    /**
   * Проверяет, может ли пользователь удалить доску
   */ async canUserDeleteBoard(boardId, userId) {
        const permissions = await this.getUserPermissions(boardId, userId);
        return permissions.canDelete;
    }
    /**
   * Проверяет, может ли пользователь создавать доски в проекте
   */ async canUserCreateBoard(projectId, userId) {
        try {
            console.log('canUserCreateBoard called with:', {
                projectId,
                userId
            });
            // Проверяем владение проектом
            const ownerQuery = `
        SELECT creator_id FROM projects WHERE id = $1
      `;
            const ownerResult = await this.databaseAdapter.query(ownerQuery, [
                projectId
            ]);
            console.log('Owner query result:', ownerResult);
            if (!ownerResult || ownerResult.length === 0) {
                console.log('Project not found');
                return false;
            }
            const projectOwner = ownerResult[0].creator_id;
            console.log('Project owner:', projectOwner, 'Current user:', userId);
            if (projectOwner === userId) {
                console.log('User is project owner - allowing board creation');
                return true;
            }
            // Проверяем членство в проекте
            const memberQuery = `
        SELECT role FROM project_members 
        WHERE project_id = $1 AND user_id = $2
      `;
            const memberResult = await this.databaseAdapter.query(memberQuery, [
                projectId,
                userId
            ]);
            console.log('Member query result:', memberResult.rows);
            const userRole = memberResult.rows?.[0]?.role;
            console.log('User role in project:', userRole);
            // Определяем права на создание досок
            switch(userRole){
                case 'admin':
                case 'member':
                    console.log('User has admin/member role - allowing board creation');
                    return true;
                case 'viewer':
                    console.log('User has viewer role - denying board creation');
                    return false;
                default:
                    console.log('User has no role in project - denying board creation');
                    return false;
            }
        } catch (error) {
            console.error('Error checking board creation permission:', error);
            return false;
        }
    }
    /**
   * Проверяет, может ли пользователь редактировать доску
   */ async canUserEditBoard(userId, boardId) {
        try {
            const board = await this.dbAdapter.getBoardById(boardId);
            if (!board) {
                return false;
            }
            const user = await this.dbAdapter.getUserById(userId);
            if (!user) {
                return false;
            }
            // Администраторы могут редактировать любые доски
            if (user.role === 'admin') {
                return true;
            }
            // Владелец проекта может редактировать доски
            const project = await this.dbAdapter.getProjectById(board.projectId);
            if (project && project.createdBy === userId) {
                return true;
            }
            // Создатель доски может редактировать
            if (board.createdBy === userId) {
                return true;
            }
            // Проверяем роль в проекте
            const projectMember = await this.dbAdapter.getProjectMember(board.projectId, userId);
            if (projectMember && (projectMember.role === 'admin' || projectMember.role === 'member')) {
                return true;
            }
            return false;
        } catch (error) {
            console.error('Error checking board edit permission:', error);
            return false;
        }
    }
    /**
   * Проверяет, может ли пользователь удалить доску
   */ async canUserDeleteBoard(userId, boardId) {
        try {
            const board = await this.dbAdapter.getBoardById(boardId);
            if (!board) {
                return false;
            }
            const user = await this.dbAdapter.getUserById(userId);
            if (!user) {
                return false;
            }
            // Только администраторы могут удалять доски
            if (user.role === 'admin') {
                return true;
            }
            // Владелец проекта может удалять доски
            const project = await this.dbAdapter.getProjectById(board.projectId);
            if (project && project.createdBy === userId) {
                return true;
            }
            return false;
        } catch (error) {
            console.error('Error checking board delete permission:', error);
            return false;
        }
    }
}
}}),
"[project]/src/lib/database-adapter.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname, a: __turbopack_async_module__ } = __turbopack_context__;
__turbopack_async_module__(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {
// =====================================================
// АДАПТЕР ДЛЯ РАБОТЫ С БАЗАМИ ДАННЫХ (PostgreSQL)
// =====================================================
__turbopack_context__.s({
    "DatabaseAdapter": (()=>DatabaseAdapter),
    "dbAdapter": (()=>dbAdapter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$postgresql$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/postgresql-adapter.ts [app-route] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$postgresql$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__
]);
([__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$postgresql$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__);
;
class DatabaseAdapter {
    static instance;
    currentDatabase = 'postgresql';
    isInitialized = false;
    postgresqlAdapter;
    constructor(){
        this.postgresqlAdapter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$postgresql$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getPostgreSQLAdapter"])();
        this.currentDatabase = 'postgresql';
    }
    static getInstance() {
        if (!DatabaseAdapter.instance) {
            DatabaseAdapter.instance = new DatabaseAdapter();
        }
        return DatabaseAdapter.instance;
    }
    /**
   * Инициализация адаптера
   */ async initialize() {
        if (this.isInitialized) return;
        try {
            // Используем PostgreSQL
            await this.postgresqlAdapter.initialize();
            this.currentDatabase = 'postgresql';
            console.log('🎯 Database Adapter: Используется PostgreSQL');
            this.isInitialized = true;
            console.log('✅ Database Adapter: Инициализация завершена');
        } catch (error) {
            console.error('❌ Database Adapter: Ошибка инициализации PostgreSQL:', error);
            throw error;
        }
    }
    /**
   * Получение статуса базы данных
   */ async getDatabaseStatus() {
        const postgresql = await Promise.resolve(this.postgresqlAdapter.initialize()).then(()=>true).catch(()=>false);
        return {
            postgresql,
            current: this.currentDatabase
        };
    }
    /**
   * Получение текущей базы данных
   */ getCurrentDatabase() {
        return this.currentDatabase;
    }
    // =====================================================
    // ОПЕРАЦИИ С ПОЛЬЗОВАТЕЛЯМИ
    // =====================================================
    /**
   * Создание пользователя
   */ async createUser(userData) {
        await this.initialize();
        const { email, password, name, role = 'user' } = userData;
        return await this.postgresqlAdapter.createUser(email, password, name, role);
    }
    /**
   * Получение пользователя по ID
   */ async getUserById(id) {
        await this.initialize();
        return await this.postgresqlAdapter.getUserById(id);
    }
    /**
   * Получение пользователя по email
   */ async getUserByEmail(email) {
        await this.initialize();
        return await this.postgresqlAdapter.getUserByEmail(email);
    }
    /**
   * Получение всех пользователей
   */ async getAllUsers() {
        await this.initialize();
        return await this.postgresqlAdapter.getAllUsers();
    }
    /**
   * Обновление пользователя
   */ async updateUser(id, updates) {
        await this.initialize();
        return await this.postgresqlAdapter.updateUser(id, updates);
    }
    /**
   * Удаление пользователя
   */ async deleteUser(id) {
        await this.initialize();
        return await this.postgresqlAdapter.deleteUser(id);
    }
    // =====================================================
    // ОПЕРАЦИИ С СЕССИЯМИ
    // =====================================================
    /**
   * Создание сессии
   */ async createSession(sessionData) {
        await this.initialize();
        const { session_token, user_id, expires_at } = sessionData;
        return await this.postgresqlAdapter.createSession(session_token, user_id, new Date(expires_at));
    }
    /**
   * Получение сессии по токену
   */ async getSessionByToken(token) {
        await this.initialize();
        return await this.postgresqlAdapter.getSessionByToken(token);
    }
    /**
   * Обновление активности сессии
   */ async updateSessionActivity(token) {
        await this.initialize();
        // Для PostgreSQL можно реализовать обновление времени последней активности
        return true;
    }
    /**
   * Удаление сессии
   */ async deleteSession(token) {
        await this.initialize();
        return await this.postgresqlAdapter.deleteSession(token);
    }
    // =====================================================
    // ОПЕРАЦИИ С ПРОЕКТАМИ
    // =====================================================
    /**
   * Создание проекта
   */ async createProject(projectData) {
        await this.initialize();
        const { name, description, creator_id, color } = projectData;
        return await this.postgresqlAdapter.createProject(name, description || '', creator_id, color);
    }
    /**
   * Получение проекта по ID
   */ async getProjectById(id) {
        await this.initialize();
        return await this.postgresqlAdapter.getProjectById(id);
    }
    /**
   * Получение всех проектов
   */ async getAllProjects() {
        await this.initialize();
        // Для PostgreSQL получаем все проекты через пользователя (требует user_id)
        // Возвращаем пустой массив, так как метод требует конкретного пользователя
        return [];
    }
    /**
   * Получение проектов пользователя
   */ async getUserProjects(userId) {
        await this.initialize();
        return await this.postgresqlAdapter.getProjectsByUserId(userId);
    }
    /**
   * Получение проектов по ID создателя
   */ async getProjectsByCreatorId(creatorId) {
        await this.initialize();
        return await this.postgresqlAdapter.getProjectsByUserId(creatorId);
    }
    /**
   * Проверка доступа к проекту
   */ async hasProjectAccess(userId, projectId) {
        await this.initialize();
        return await this.postgresqlAdapter.hasProjectAccess(userId.toString(), projectId);
    }
    // =====================================================
    // ОПЕРАЦИИ С ДОСКАМИ
    // =====================================================
    /**
   * Получение досок проекта
   */ async getProjectBoards(projectId) {
        await this.initialize();
        return await this.postgresqlAdapter.getBoardsByProjectId(projectId);
    }
    // =====================================================
    // ОПЕРАЦИИ С КОЛОНКАМИ
    // =====================================================
    /**
   * Получение колонок доски
   */ async getBoardColumns(boardId) {
        await this.initialize();
        return await this.postgresqlAdapter.getColumnsByBoardId(boardId);
    }
    /**
   * Создание колонки
   */ async createColumn(columnData) {
        await this.initialize();
        const { name, board_id, position, color } = columnData;
        return await this.postgresqlAdapter.createColumn(name, board_id, position, color);
    }
    // =====================================================
    // ОПЕРАЦИИ С ЗАДАЧАМИ
    // =====================================================
    /**
   * Создание задачи
   */ async createTask(taskData) {
        await this.initialize();
        return await this.postgresqlAdapter.createTask(taskData);
    }
    /**
   * Получение задач колонки
   */ async getColumnTasks(columnId) {
        await this.initialize();
        return await this.postgresqlAdapter.getTasksByColumnId(columnId);
    }
    /**
   * Удаление задачи
   */ async deleteTask(id) {
        await this.initialize();
        return await this.postgresqlAdapter.deleteTask(id);
    }
    /**
   * Выполнение сырого SQL запроса (для совместимости с репозиториями)
   */ async query(sql, params) {
        await this.initialize();
        const result = await this.postgresqlAdapter.query(sql, params);
        return result.rows || [];
    }
}
const dbAdapter = DatabaseAdapter.getInstance();
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
"[project]/src/app/api/boards/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname, a: __turbopack_async_module__ } = __turbopack_context__;
__turbopack_async_module__(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {
__turbopack_context__.s({
    "DELETE": (()=>DELETE),
    "GET": (()=>GET),
    "POST": (()=>POST)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/auth.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v4/classic/external.js [app-route] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$implementations$2f$board$2e$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/services/implementations/board.service.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$implementations$2f$board$2e$repository$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/services/implementations/board.repository.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$implementations$2f$board$2e$validator$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/services/implementations/board.validator.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$implementations$2f$permission$2e$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/services/implementations/permission.service.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/database-adapter.ts [app-route] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__,
    __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__
]);
([__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__);
;
;
;
;
;
;
;
;
const createBoardSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().min(1, 'Board name is required'),
    description: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    projectId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().min(1, 'Project ID is required'),
    visibility: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].enum([
        'private',
        'public'
    ]).default('private'),
    color: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().regex(/^#[0-9A-F]{6}$/i, 'Invalid color format').optional()
});
// Инициализация сервисов
const boardRepository = new __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$implementations$2f$board$2e$repository$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BoardRepository"](__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["dbAdapter"]);
const boardValidator = new __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$implementations$2f$board$2e$validator$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BoardValidator"]();
const permissionService = new __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$implementations$2f$permission$2e$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PermissionService"](__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["dbAdapter"]);
const boardService = new __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$implementations$2f$board$2e$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BoardService"](boardRepository, boardValidator, permissionService, null, null // cache service
);
async function GET(request) {
    try {
        // Проверка авторизации
        const authResult = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["verifyAuth"])(request);
        if (!authResult.success) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: authResult.error
            }, {
                status: 401
            });
        }
        const { userId } = authResult.user;
        const { searchParams } = new URL(request.url);
        const projectId = searchParams.get('projectId');
        if (!projectId || projectId === 'null' || projectId === 'undefined' || projectId.trim() === '') {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'ID проекта обязателен'
            }, {
                status: 400
            });
        }
        // Проверка доступа к проекту
        const hasAccess = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["dbAdapter"].hasProjectAccess(userId, projectId);
        if (!hasAccess) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Нет доступа к проекту'
            }, {
                status: 403
            });
        }
        // Используем новый сервис для получения досок
        const result = await boardService.getBoardsByProject(projectId, userId, {
            includeArchived: searchParams.get('includeArchived') === 'true',
            sortBy: searchParams.get('sortBy') || 'position',
            sortOrder: searchParams.get('sortOrder') || 'asc'
        });
        if (!result.success) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: result.error
            }, {
                status: 400
            });
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            boards: result.data
        });
    } catch (error) {
        console.error('Ошибка получения досок:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Внутренняя ошибка сервера'
        }, {
            status: 500
        });
    }
}
async function POST(request) {
    try {
        const authResult = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["verifyAuth"])(request);
        if (!authResult.success) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: authResult.error
            }, {
                status: 401
            });
        }
        const { userId } = authResult.user;
        const body = await request.json();
        const validatedData = createBoardSchema.parse(body);
        // Проверяем права на создание доски
        const canCreate = await permissionService.canUserCreateBoard(validatedData.projectId, userId);
        if (!canCreate) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Нет прав на создание досок в этом проекте'
            }, {
                status: 403
            });
        }
        // Используем новый сервис для создания доски
        const result = await boardService.createBoard({
            name: validatedData.name,
            description: validatedData.description || null,
            projectId: validatedData.projectId,
            visibility: validatedData.visibility,
            color: validatedData.color || '#3B82F6',
            settings: {
                allowTaskCreation: true,
                allowColumnReordering: true,
                enableTaskLimits: false,
                defaultTaskPriority: 'medium',
                autoArchiveCompletedTasks: false
            }
        }, userId);
        if (!result.success) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: result.error
            }, {
                status: 400
            });
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            board: result.data
        }, {
            status: 201
        });
    } catch (error) {
        if (error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].ZodError) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Validation error',
                details: error.errors
            }, {
                status: 400
            });
        }
        console.error('Error creating board:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Internal server error'
        }, {
            status: 500
        });
    }
}
async function DELETE(request) {
    try {
        const authResult = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["verifyAuth"])(request);
        if (!authResult.success) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: authResult.error
            }, {
                status: 401
            });
        }
        const { user } = authResult;
        const { searchParams } = new URL(request.url);
        const boardId = searchParams.get('boardId');
        if (!boardId) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'ID доски обязателен'
            }, {
                status: 400
            });
        }
        // Проверка прав на удаление доски
        const canDelete = await permissionService.canUserDeleteBoard(user.id, Number(boardId));
        if (!canDelete) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Недостаточно прав для удаления доски'
            }, {
                status: 403
            });
        }
        // Используем новый сервис для удаления доски
        const result = await boardService.delete(boardId, user.id);
        if (!result.success) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: result.error
            }, {
                status: 400
            });
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            message: 'Доска успешно удалена'
        }, {
            status: 200
        });
    } catch (error) {
        console.error('Ошибка удаления доски:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Внутренняя ошибка сервера'
        }, {
            status: 500
        });
    }
}
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__c0121d72._.js.map